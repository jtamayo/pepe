diff -r -N -w -u -I '[$]Id:' --exclude='*.class' --exclude='.*' --exclude='*.orig' --exclude='*.rej' --exclude=CVS --exclude='#*' --exclude='*~' ./rvm/config/build/BaseAdaptiveMeasurement ./rvm/config/build/BaseAdaptiveMeasurement
--- ./rvm/config/build/BaseAdaptiveMeasurement	1970-01-01 10:00:00.000000000 +1000
+++ ./rvm/config/build/BaseAdaptiveMeasurement	2006-11-26 00:20:41.000000000 +1100
@@ -0,0 +1,2 @@
+. $1/gc/Measurement
+. $1/compilers/BaseAdaptive
diff -r -N -w -u -I '[$]Id:' --exclude='*.class' --exclude='.*' --exclude='*.orig' --exclude='*.rej' --exclude=CVS --exclude='#*' --exclude='*~' ./rvm/config/build/BaseBaseMeasurement ./rvm/config/build/BaseBaseMeasurement
--- ./rvm/config/build/BaseBaseMeasurement	1970-01-01 10:00:00.000000000 +1000
+++ ./rvm/config/build/BaseBaseMeasurement	2006-11-26 00:20:41.000000000 +1100
@@ -0,0 +1,2 @@
+. $1/gc/Measurement
+. $1/compilers/BaseBase
diff -r -N -w -u -I '[$]Id:' --exclude='*.class' --exclude='.*' --exclude='*.orig' --exclude='*.rej' --exclude=CVS --exclude='#*' --exclude='*~' ./rvm/config/build/FastAdaptiveMeasurement ./rvm/config/build/FastAdaptiveMeasurement
--- ./rvm/config/build/FastAdaptiveMeasurement	1970-01-01 10:00:00.000000000 +1000
+++ ./rvm/config/build/FastAdaptiveMeasurement	2006-11-26 00:20:41.000000000 +1100
@@ -0,0 +1,2 @@
+. $1/gc/Measurement
+. $1/compilers/FastAdaptive
diff -r -N -w -u -I '[$]Id:' --exclude='*.class' --exclude='.*' --exclude='*.orig' --exclude='*.rej' --exclude=CVS --exclude='#*' --exclude='*~' ./rvm/config/build/FullAdaptiveMeasurement ./rvm/config/build/FullAdaptiveMeasurement
--- ./rvm/config/build/FullAdaptiveMeasurement	1970-01-01 10:00:00.000000000 +1000
+++ ./rvm/config/build/FullAdaptiveMeasurement	2006-11-26 00:20:41.000000000 +1100
@@ -0,0 +1,2 @@
+. $1/gc/Measurement
+. $1/compilers/FullAdaptive
diff -r -N -w -u -I '[$]Id:' --exclude='*.class' --exclude='.*' --exclude='*.orig' --exclude='*.rej' --exclude=CVS --exclude='#*' --exclude='*~' ./rvm/config/build/gc/Measurement ./rvm/config/build/gc/Measurement
--- ./rvm/config/build/gc/Measurement	1970-01-01 10:00:00.000000000 +1000
+++ ./rvm/config/build/gc/Measurement	2006-11-26 00:20:41.000000000 +1100
@@ -0,0 +1,3 @@
+   export RVM_WITH_MMTK_INLINE_PLAN=1
+   export RVM_WITH_MMTK_PLAN="org.mmtk.plan.measurement.Measure"
+
diff -r -N -w -u -I '[$]Id:' --exclude='*.class' --exclude='.*' --exclude='*.orig' --exclude='*.rej' --exclude=CVS --exclude='#*' --exclude='*~' ./rvm/src/vm/memoryManagers/JMTk/vmInterface/MM_Interface.java ./rvm/src/vm/memoryManagers/JMTk/vmInterface/MM_Interface.java
--- ./rvm/src/vm/memoryManagers/JMTk/vmInterface/MM_Interface.java	2006-11-26 00:21:14.000000000 +1100
+++ ./rvm/src/vm/memoryManagers/JMTk/vmInterface/MM_Interface.java	2006-11-26 00:34:45.000000000 +1100
@@ -988,15 +988,19 @@
     if (vmType.isArrayType()) {
       type = new MMType(false,
                         vmType.asArray().getElementType().isReferenceType(),
+                        true,
                         vmType.isAcyclicReference(),
                         pickAllocatorForType(vmType),
-                        zeroLengthIntArray);
+                        zeroLengthIntArray,
+                        vmType.getDescriptor().toByteArray());
     } else {
       type = new MMType(false,
                         false,
+                        false,
                         vmType.isAcyclicReference(),
                         pickAllocatorForType(vmType),
-                        vmType.asClass().getReferenceOffsets());
+                        vmType.asClass().getReferenceOffsets(),
+                        vmType.getDescriptor().toByteArray());
     }
     vmType.setMMType(type);
   }
@@ -1007,8 +1011,8 @@
    * benchmark, such as a full heap collection, turning on
    * instrumentation, etc.
    */
-  public static void harnessBegin() throws InterruptiblePragma {
-    Plan.harnessBegin();
+  public static void harnessBegin() throws UninterruptibleNoWarnPragma {
+    SelectedPlan.get().harnessBegin();
   }
 
   /**
@@ -1017,8 +1021,8 @@
    * benchmark, such as a full heap collection, turning off
    * instrumentation, etc.
    */
-  public static void harnessEnd() {
-    Plan.harnessEnd();
+  public static void harnessEnd() throws UninterruptibleNoWarnPragma {
+    SelectedPlan.get().harnessEnd();
   }
 
   /**
diff -r -N -w -u -I '[$]Id:' --exclude='*.class' --exclude='.*' --exclude='*.orig' --exclude='*.rej' --exclude=CVS --exclude='#*' --exclude='*~' ./MMTk/ext/vm/JikesRVM/org/mmtk/vm/ObjectModel.java ./MMTk/ext/vm/JikesRVM/org/mmtk/vm/ObjectModel.java
--- ./MMTk/ext/vm/JikesRVM/org/mmtk/vm/ObjectModel.java	2006-11-26 00:19:45.000000000 +1100
+++ ./MMTk/ext/vm/JikesRVM/org/mmtk/vm/ObjectModel.java	2006-11-26 00:20:41.000000000 +1100
@@ -8,6 +8,7 @@
 
 import org.mmtk.utility.scan.MMType;
 import org.mmtk.utility.Constants;
+import org.mmtk.utility.statistics.Measurement;
 import org.mmtk.utility.alloc.Allocator;
 
 import com.ibm.JikesRVM.VM;
@@ -35,7 +36,7 @@
  * @version $Revision: 1.6 $
  * @date $Date: 2006/06/19 06:08:15 $
  */
-public class ObjectModel implements Constants, VM_Constants, Uninterruptible {
+public class ObjectModel implements VM_Constants, Uninterruptible {
   /**
    * Copy an object using a plan's allocCopy to get space and install
    * the forwarding pointer.  On entry, <code>from</code> must have
@@ -399,5 +400,58 @@
     if (VM.VerifyAssertions) VM._assert(vmType.getMMType() != null);
     return (MMType) vmType.getMMType();
   }
+  
+  /*
+   * Extra header fields for the measurement collector
+   */
+  private static final Offset BIRTHDAY_HIGH = GC_HEADER_OFFSET();
+  private static final Offset BIRTHDAY_LOW = BIRTHDAY_HIGH.plus(BYTES_IN_INT);
+  private static final Offset REFCOUNT = BIRTHDAY_LOW.plus(BYTES_IN_INT);
+  private static final Offset PTRCOUNT = REFCOUNT.plus(BYTES_IN_INT);
+  
+  /**
+   * set the birthdate of an object - Measurement plan specific, lives in 
+   * an extra word in the header
+   */
+  public static void setBirthdate(ObjectReference object, long birthday) {
+    if (Assert.VERIFY_ASSERTIONS)
+      Assert._assert(Measurement.MEASURE_DETAIL,"Measurement header does not exist");
+    //-#if RVM_FOR_64_ADDR
+    object.toAddress().store(Word.fromLong(birthday) ,BIRTHDAY_HIGH);
+    //-#else
+    Word high = Word.fromInt((int)((birthday&0xFFFFFFFF00000000L)>>BITS_IN_WORD));
+    Word low  = Word.fromInt((int)( birthday&0x00000000FFFFFFFFL));
+    object.toAddress().store(high ,BIRTHDAY_HIGH);
+    object.toAddress().store(low  ,BIRTHDAY_LOW);
+    //-#endif
+  }
+  
+  /**
+   * get the birthdate of an object - Measurement plan specific, lives in 
+   * an extra word in the header
+   */
+  public static long getBirthdate(ObjectReference object) {
+    //-#if RVM_FOR_64_ADDR
+    return object.toAddress().loadWord(BIRTHDAY_HIGH).toLong();
+    //-#else
+    long high = (long)(object.toAddress().loadWord(BIRTHDAY_HIGH).toInt())<<BITS_IN_WORD;
+    long low = object.toAddress().loadWord(BIRTHDAY_LOW).toInt()&0xFFFFFFFFL;
+    return high | low;
+    //-#endif
+  }
+
+  public static void setRefcount(ObjectReference object, Word count) {
+    int c = count.toInt();
+    object.toAddress().store(count ,REFCOUNT);
+  }
+  public static Word getRefcount(ObjectReference object) {
+    return Word.fromIntZeroExtend(object.toAddress().loadInt(REFCOUNT));
+  }
+  public static void setPtrcount(ObjectReference object, int count) {
+    object.toAddress().store(count ,PTRCOUNT);
+  }
+  public static int getPtrcount(ObjectReference object) {
+    return object.toAddress().loadInt(PTRCOUNT);
+  }
 }
 
diff -r -N -w -u -I '[$]Id:' --exclude='*.class' --exclude='.*' --exclude='*.orig' --exclude='*.rej' --exclude=CVS --exclude='#*' --exclude='*~' ./MMTk/ext/vm/stub/org/mmtk/vm/ObjectModel.java ./MMTk/ext/vm/stub/org/mmtk/vm/ObjectModel.java
--- ./MMTk/ext/vm/stub/org/mmtk/vm/ObjectModel.java	2006-11-26 00:19:45.000000000 +1100
+++ ./MMTk/ext/vm/stub/org/mmtk/vm/ObjectModel.java	2006-11-26 00:20:41.000000000 +1100
@@ -274,4 +274,26 @@
   public static MMType getObjectType(ObjectReference object) {
     return null;
   }
+  
+  /**
+   * set the birthdate of an object
+   */
+  public static void setBirthdate(ObjectReference object, long birthday) { }
+  
+  /**
+   * get the birthdate of an object
+   */
+  public static long getBirthdate(ObjectReference object) {
+    return 0l;
+  }
+  
+  /**
+   * get/set the refcount of an object
+   */
+  public static void setRefcount(ObjectReference object, Word count) {}
+  public static Word getRefcount(ObjectReference object) { return Word.zero(); }
+  
+  public static void setPtrcount(ObjectReference object, int count) {}
+  public static int getPtrcount(ObjectReference object) { return 0; }
+  
 }
diff -r -N -w -u -I '[$]Id:' --exclude='*.class' --exclude='.*' --exclude='*.orig' --exclude='*.rej' --exclude=CVS --exclude='#*' --exclude='*~' ./MMTk/src/org/mmtk/plan/generational/GenNurseryTraceLocal.java ./MMTk/src/org/mmtk/plan/generational/GenNurseryTraceLocal.java
--- ./MMTk/src/org/mmtk/plan/generational/GenNurseryTraceLocal.java	2006-11-26 00:19:45.000000000 +1100
+++ ./MMTk/src/org/mmtk/plan/generational/GenNurseryTraceLocal.java	2006-11-26 00:20:41.000000000 +1100
@@ -88,7 +88,7 @@
     logMessage(5, "processing remset");
     while (!remset.isEmpty()) {
       Address loc = remset.pop();
-      traceObjectLocation(loc, false);
+      traceObjectLocation(null, loc, false);
     }
     logMessage(5, "processing array remset");
     arrayRemset.flushLocal();
@@ -96,7 +96,7 @@
       Address start = arrayRemset.pop1();
       Address guard = arrayRemset.pop2();
       while (start.LT(guard)) {
-        traceObjectLocation(start, false);
+        traceObjectLocation(null, start, false);
         start = start.plus(BYTES_IN_ADDRESS);
       }
     }
diff -r -N -w -u -I '[$]Id:' --exclude='*.class' --exclude='.*' --exclude='*.orig' --exclude='*.rej' --exclude=CVS --exclude='#*' --exclude='*~' ./MMTk/src/org/mmtk/plan/measurement/MeasureCollector.java ./MMTk/src/org/mmtk/plan/measurement/MeasureCollector.java
--- ./MMTk/src/org/mmtk/plan/measurement/MeasureCollector.java	1970-01-01 10:00:00.000000000 +1000
+++ ./MMTk/src/org/mmtk/plan/measurement/MeasureCollector.java	2006-11-26 00:20:41.000000000 +1100
@@ -0,0 +1,32 @@
+package org.mmtk.plan.measurement;
+
+import org.mmtk.plan.TraceLocal;
+import org.mmtk.plan.semispace.SSCollector;
+import org.mmtk.vm.ActivePlan;
+
+import org.vmmagic.pragma.*;
+
+public class MeasureCollector extends SSCollector implements Uninterruptible {
+
+  /****************************************************************************
+   * Instance fields
+   */
+
+  public MeasureCollector() {
+    super();
+  }
+
+  protected void initTrace() throws InterruptiblePragma {
+    trace = new MeasureTraceLocal(global().ssTrace);
+  }
+
+  /****************************************************************************
+   * 
+   * Miscellaneous
+   */
+
+  /** @return The active global plan as an <code>SS</code> instance. */
+  private static final Measure global() throws InlinePragma {
+    return (Measure) ActivePlan.global();
+  }
+}
diff -r -N -w -u -I '[$]Id:' --exclude='*.class' --exclude='.*' --exclude='*.orig' --exclude='*.rej' --exclude=CVS --exclude='#*' --exclude='*~' ./MMTk/src/org/mmtk/plan/measurement/MeasureConstraints.java ./MMTk/src/org/mmtk/plan/measurement/MeasureConstraints.java
--- ./MMTk/src/org/mmtk/plan/measurement/MeasureConstraints.java	1970-01-01 10:00:00.000000000 +1000
+++ ./MMTk/src/org/mmtk/plan/measurement/MeasureConstraints.java	2006-11-26 00:20:41.000000000 +1100
@@ -0,0 +1,17 @@
+package org.mmtk.plan.measurement;
+
+import org.mmtk.plan.semispace.SSConstraints;
+import org.mmtk.utility.statistics.Measurement;
+
+import org.vmmagic.pragma.*;
+
+public class MeasureConstraints extends SSConstraints implements Uninterruptible {
+
+  public int gcHeaderWords() {
+    return super.gcHeaderWords() + Measurement.MEASUREMENT_HEADER_WORDS;
+  }
+  
+  public boolean needsWriteBarrier() {
+    return super.needsWriteBarrier() || Measurement.MEASURE_DETAIL;
+  }
+}
diff -r -N -w -u -I '[$]Id:' --exclude='*.class' --exclude='.*' --exclude='*.orig' --exclude='*.rej' --exclude=CVS --exclude='#*' --exclude='*~' ./MMTk/src/org/mmtk/plan/measurement/Measure.java ./MMTk/src/org/mmtk/plan/measurement/Measure.java
--- ./MMTk/src/org/mmtk/plan/measurement/Measure.java	1970-01-01 10:00:00.000000000 +1000
+++ ./MMTk/src/org/mmtk/plan/measurement/Measure.java	2006-11-26 00:20:41.000000000 +1100
@@ -0,0 +1,77 @@
+package org.mmtk.plan.measurement;
+
+import org.mmtk.plan.semispace.SS;
+import org.mmtk.utility.options.*;
+import org.mmtk.utility.statistics.Measurement;
+
+import org.vmmagic.pragma.*;
+
+public class Measure extends SS implements Uninterruptible {
+
+  static long lastStressTime = 0;
+  
+  static {
+    Options.cohortSize = new CohortSize();
+  }
+  
+  public Measure() {
+    super();
+  }
+
+  /** 
+   * Start the measurement subsystem at boot time, after options 
+   * become available
+   */
+  public void postBoot() throws InterruptiblePragma {
+    super.postBoot();
+    if (Measurement.MEASURE_DETAIL) 
+      Measurement.boot();
+  }
+  
+  /** Add some measurement calls to the benchmark harness */
+  public void harnessBegin() throws InterruptiblePragma {
+    super.harnessBegin();
+    Measurement.start();
+  }
+  
+  /** Add some measurement calls to the benchmark harness */
+  public void harnessEnd() throws InterruptiblePragma {
+    System.gc();
+    Measurement.stop();
+    Measurement.harnessEnd();
+    super.harnessEnd();
+  }
+  
+  /**
+   * Redefine stress test conditions so that it only applies during
+   * the measurement phase.
+   * 
+   * @return True is a stress test GC is required
+   */
+  public boolean stressTestGCRequired() throws InlinePragma {
+    long now = Measurement.now();
+    if (insideHarness &&
+        ((now ^ lastStressTime) > Options.cohortSize.getBytes().toInt())) {
+      lastStressTime = now;
+      return true;
+    } else
+      return false;
+  }
+  
+  /**
+   * Put hooks into the GC process
+   */
+  public void collectionPhase(int phase) throws InlinePragma {
+    if (phase == PREPARE) {
+      Measurement.gcStart();
+      super.collectionPhase(phase);
+      return;
+    }
+    if (phase == RELEASE) {
+      super.collectionPhase(phase);
+      Measurement.gcEnd();
+      return;
+    }
+    super.collectionPhase(phase);
+  }
+}
diff -r -N -w -u -I '[$]Id:' --exclude='*.class' --exclude='.*' --exclude='*.orig' --exclude='*.rej' --exclude=CVS --exclude='#*' --exclude='*~' ./MMTk/src/org/mmtk/plan/measurement/MeasureMutator.java ./MMTk/src/org/mmtk/plan/measurement/MeasureMutator.java
--- ./MMTk/src/org/mmtk/plan/measurement/MeasureMutator.java	1970-01-01 10:00:00.000000000 +1000
+++ ./MMTk/src/org/mmtk/plan/measurement/MeasureMutator.java	2006-11-26 00:20:41.000000000 +1100
@@ -0,0 +1,107 @@
+package org.mmtk.plan.measurement;
+
+import org.mmtk.plan.semispace.SS;
+import org.mmtk.plan.semispace.SSMutator;
+import org.mmtk.utility.statistics.*;
+import org.mmtk.vm.Barriers;
+
+import org.vmmagic.unboxed.*;
+import org.vmmagic.pragma.*;
+
+public class MeasureMutator extends SSMutator implements Uninterruptible {
+  private static SizeCounter allocCount = new SizeCounter("alloc",true,true);
+
+  /****************************************************************************
+   *
+   * Allocation
+   */
+  //public Address alloc(int bytes, int align, int offset, int allocator)
+  //throws InlinePragma {
+    //sanityCountAlloc(bytes);
+    //return super.alloc(bytes, align, offset, allocator);
+  //}
+
+
+
+  /**
+   * @param bytes
+   */
+  private void sanityCountAlloc(int bytes) throws NoInlinePragma {
+    allocCount.inc(bytes - Measurement.MEASUREMENT_HEADER_BYTES);
+  }
+  
+  
+  
+  /**
+   * Allocate space (for an object)
+   *
+   * @param bytes The size of the space to be allocated (in bytes)
+   * @param align The requested alignment.
+   * @param offset The alignment offset.
+   * @param allocator The allocator number to be used for this allocation
+   * @return The address of the first byte of the allocated region
+   */
+  public void postAlloc(ObjectReference object, ObjectReference typeRef,
+          int bytes, int allocator)
+    throws InlinePragma {
+    if (Measurement.MEASURE_DETAIL) {
+      Measurement.objectCreation(object, bytes);
+    }
+    super.postAlloc(object,typeRef, bytes, allocator);
+  }
+  
+  /**
+   * A new reference is about to be created.  Take appropriate write
+   * barrier actions.<p> 
+   *
+   * In this case, we remember the address of the source of the
+   * pointer if the new reference points into the nursery from
+   * non-nursery space.
+   *
+   * @param src The object into which the new reference will be stored
+   * @param slot The address into which the new reference will be
+   * stored.
+   * @param tgt The target of the new reference
+   * @param metaDataA A field used by the VM to create a correct store.
+   * @param metaDataB A field used by the VM to create a correct store.
+   * @param mode The mode of the store (eg putfield, putstatic etc)
+   */
+  public void writeBarrier(ObjectReference src, Address slot,
+          ObjectReference tgt, Offset metaDataA,
+          int metaDataB, int mode)
+  throws InlinePragma {
+    Measurement.pointerMutation(src, slot, tgt);
+    Barriers.performWriteInBarrier(src, slot, tgt, metaDataA, metaDataB, mode);
+  }
+  
+  /**
+   * A number of references are about to be copied from object
+   * <code>src</code> to object <code>dst</code> (as in an array
+   * copy).  Thus, <code>dst</code> is the mutated object.  Take
+   * appropriate write barrier actions.<p>
+   *
+   * In this case, we remember the mutated source address range and
+   * will scan that address range at GC time.
+   *
+   * @param src The source of the values to copied
+   * @param srcOffset The offset of the first source address, in
+   * bytes, relative to <code>src</code> (in principle, this could be
+   * negative).
+   * @param dst The mutated object, i.e. the destination of the copy.
+   * @param dstOffset The offset of the first destination address, in
+   * bytes relative to <code>tgt</code> (in principle, this could be
+   * negative).
+   * @param bytes The size of the region being copied, in bytes.
+   * @return True if the update was performed by the barrier, false if
+   * left to the caller (always false in this case).
+   */
+  public boolean writeBarrier(ObjectReference src, Offset srcOffset,
+          ObjectReference dst, Offset dstOffset,
+          int bytes)  
+  throws InlinePragma {
+    Measurement.pointerMutations(src.toAddress().plus(srcOffset).toObjectReference(), dst, bytes);
+    return false;
+  }
+  
+  
+}
diff -r -N -w -u -I '[$]Id:' --exclude='*.class' --exclude='.*' --exclude='*.orig' --exclude='*.rej' --exclude=CVS --exclude='#*' --exclude='*~' ./MMTk/src/org/mmtk/plan/measurement/MeasureTraceLocal.java ./MMTk/src/org/mmtk/plan/measurement/MeasureTraceLocal.java
--- ./MMTk/src/org/mmtk/plan/measurement/MeasureTraceLocal.java	1970-01-01 10:00:00.000000000 +1000
+++ ./MMTk/src/org/mmtk/plan/measurement/MeasureTraceLocal.java	2006-11-26 00:20:41.000000000 +1100
@@ -0,0 +1,35 @@
+package org.mmtk.plan.measurement;
+
+import org.mmtk.plan.Trace;
+import org.mmtk.plan.semispace.SSTraceLocal;
+import org.mmtk.utility.statistics.Measurement;
+import org.mmtk.vm.ObjectModel;
+import org.vmmagic.pragma.InlinePragma;
+import org.vmmagic.pragma.Uninterruptible;
+import org.vmmagic.unboxed.Address;
+import org.vmmagic.unboxed.ObjectReference;
+
+public class MeasureTraceLocal extends SSTraceLocal implements Uninterruptible {
+  public MeasureTraceLocal(Trace trace) {
+    super(trace);
+  }
+
+  //@Override
+  public void enqueue(ObjectReference object) throws InlinePragma {
+    if (Measurement.MEASURE_DETAIL)
+      Measurement.liveObject(object, ObjectModel.getSizeWhenCopied(object));
+
+    super.enqueue(object);
+  }
+
+  /* (non-Javadoc)
+   * @see org.mmtk.plan.TraceLocal#traceObjectLocation(org.vmmagic.unboxed.ObjectReference, org.vmmagic.unboxed.Address, boolean)
+   */
+  public void traceObjectLocation(ObjectReference srcObj, Address objLoc, boolean root) throws InlinePragma {
+    super.traceObjectLocation(srcObj, objLoc, root);
+    if (Measurement.MEASURE_DETAIL && !srcObj.isNull())
+      Measurement.livePointer(srcObj, objLoc.loadObjectReference());
+  }
+  
+  
+}
diff -r -N -w -u -I '[$]Id:' --exclude='*.class' --exclude='.*' --exclude='*.orig' --exclude='*.rej' --exclude=CVS --exclude='#*' --exclude='*~' ./MMTk/src/org/mmtk/plan/MutatorContext.java ./MMTk/src/org/mmtk/plan/MutatorContext.java
--- ./MMTk/src/org/mmtk/plan/MutatorContext.java	2006-11-26 00:21:14.000000000 +1100
+++ ./MMTk/src/org/mmtk/plan/MutatorContext.java	2006-11-26 00:20:41.000000000 +1100
@@ -97,7 +97,7 @@
   protected LargeObjectLocal los = new LargeObjectLocal(Plan.loSpace);
 
   /** Current dynamic allocation scope */
-  private int currentScope = Plan.DEFAULT_SCOPE;
+  public int currentScope = Plan.DEFAULT_SCOPE;
 
   /****************************************************************************
    * 
diff -r -N -w -u -I '[$]Id:' --exclude='*.class' --exclude='.*' --exclude='*.orig' --exclude='*.rej' --exclude=CVS --exclude='#*' --exclude='*~' ./MMTk/src/org/mmtk/plan/Plan.java ./MMTk/src/org/mmtk/plan/Plan.java
--- ./MMTk/src/org/mmtk/plan/Plan.java	2006-11-26 00:21:14.000000000 +1100
+++ ./MMTk/src/org/mmtk/plan/Plan.java	2006-11-26 00:34:45.000000000 +1100
@@ -67,7 +67,7 @@
   public static final int GC_PROPER = 2;
 
   /* Polling */
-  public static final int DEFAULT_POLL_FREQUENCY = (128 << 10) >> LOG_BYTES_IN_PAGE;
+  public static final int DEFAULT_POLL_FREQUENCY = (4 << 10) >> LOG_BYTES_IN_PAGE;
   public static final int META_DATA_POLL_FREQUENCY = DEFAULT_POLL_FREQUENCY;
 
   /* Space Size Constants. */
@@ -148,6 +148,7 @@
     Options.nurserySize = new NurserySize();
     Options.variableSizeHeap = new VariableSizeHeap();
     Options.sanityCheck = new SanityCheck();
+    Options.harnessWholeRun = new HarnessWholeRun();
   }
 
   /****************************************************************************
@@ -183,6 +184,8 @@
     initialized = true;
     exceptionReserve = (int) (getTotalPages() *
                               (1 - Collection.OUT_OF_MEMORY_THRESHOLD));
+    if (Options.harnessWholeRun.getValue())
+      harnessBegin();
   }
 
   /**
@@ -190,7 +193,9 @@
    * 
    * @param value The exit value
    */
-  public void notifyExit(int value) {
+  public void notifyExit(int value) throws UninterruptibleNoWarnPragma {
+    if (Options.harnessWholeRun.getValue())
+      harnessEnd();
     if (Options.verbose.getValue() == 1) {
       Log.write("[End ");
       totalTime.printTotalSecs();
@@ -253,7 +258,7 @@
     return false;
   }
 
-  private long lastStressPages = 0;
+  protected long lastStressPages = 0;
 
   /**
    * @return The current sanity checker.
@@ -265,7 +270,7 @@
   /**
    * @return True is a stress test GC is required
    */
-  public final boolean stressTestGCRequired()
+  public boolean stressTestGCRequired()
     throws InlinePragma {
     long pages = Space.cumulativeCommittedPages();
     if (initialized &&
@@ -437,7 +442,7 @@
    * instrumentation, etc.  By default we do a full heap GC,
    * and then start stats collection.
    */
-  public static void harnessBegin() throws InterruptiblePragma {
+  public void harnessBegin() throws InterruptiblePragma {
     // Save old values.
     boolean oldFullHeap = Options.fullHeapSystemGC.getValue();
     boolean oldIgnore = Options.ignoreSystemGC.getValue();
@@ -465,7 +470,7 @@
    * instrumentation, etc.  By default we stop all statistics objects
    * and print their values.
    */
-  public static void harnessEnd() {
+  public void harnessEnd() throws InterruptiblePragma {
     Stats.stopAll();
     Stats.printStats();
     insideHarness = false;
diff -r -N -w -u -I '[$]Id:' --exclude='*.class' --exclude='.*' --exclude='*.orig' --exclude='*.rej' --exclude=CVS --exclude='#*' --exclude='*~' ./MMTk/src/org/mmtk/plan/refcount/generational/GenRCMutator.java ./MMTk/src/org/mmtk/plan/refcount/generational/GenRCMutator.java
--- ./MMTk/src/org/mmtk/plan/refcount/generational/GenRCMutator.java	2006-11-26 00:19:45.000000000 +1100
+++ ./MMTk/src/org/mmtk/plan/refcount/generational/GenRCMutator.java	2006-11-26 00:20:41.000000000 +1100
@@ -300,7 +300,7 @@
     if (!object.isNull()) {
       if (Space.isInSpace(GenRC.NS, object)) {
         // FIXME. THIS ONLY EXISTS BECUASE MUTATOR & COLLECTOR ARE CONFUSED!
-       ((GenRCCollector) ActivePlan.collector()).trace.traceObjectLocation(objLoc);
+       ((GenRCCollector) ActivePlan.collector()).trace.traceObjectLocation(null, objLoc);
       } else if (GenRC.isRCObject(object))
         RefCountSpace.incRC(object);
     }
diff -r -N -w -u -I '[$]Id:' --exclude='*.class' --exclude='.*' --exclude='*.orig' --exclude='*.rej' --exclude=CVS --exclude='#*' --exclude='*~' ./MMTk/src/org/mmtk/plan/semispace/SSCollector.java ./MMTk/src/org/mmtk/plan/semispace/SSCollector.java
--- ./MMTk/src/org/mmtk/plan/semispace/SSCollector.java	2006-11-26 00:19:45.000000000 +1100
+++ ./MMTk/src/org/mmtk/plan/semispace/SSCollector.java	2006-11-26 00:20:41.000000000 +1100
@@ -8,8 +8,11 @@
 import org.mmtk.policy.CopySpace;
 import org.mmtk.policy.CopyLocal;
 import org.mmtk.policy.Space;
+import org.mmtk.utility.Log;
+import org.mmtk.utility.statistics.Measurement;
 import org.mmtk.vm.ActivePlan;
 import org.mmtk.vm.Assert;
+import org.mmtk.vm.ObjectModel;
 
 import org.vmmagic.unboxed.*;
 import org.vmmagic.pragma.*;
@@ -47,7 +50,7 @@
    * Instance fields
    */
 
-  protected final SSTraceLocal trace;
+  protected SSTraceLocal trace;
   protected final CopyLocal ss;
 
   /****************************************************************************
@@ -60,6 +63,10 @@
    */
   public SSCollector() {
     ss = new CopyLocal(SS.copySpace0);
+    initTrace();
+  }
+
+  protected void initTrace() throws InterruptiblePragma {
     trace = new SSTraceLocal(global().ssTrace);
   }
 
@@ -85,7 +92,6 @@
       Assert._assert(bytes <= Plan.LOS_SIZE_THRESHOLD);
       Assert._assert(allocator == SS.ALLOC_SS);
     }
-
     return ss.alloc(bytes, align, offset, true);
   }
 
diff -r -N -w -u -I '[$]Id:' --exclude='*.class' --exclude='.*' --exclude='*.orig' --exclude='*.rej' --exclude=CVS --exclude='#*' --exclude='*~' ./MMTk/src/org/mmtk/plan/TraceLocal.java ./MMTk/src/org/mmtk/plan/TraceLocal.java
--- ./MMTk/src/org/mmtk/plan/TraceLocal.java	2006-11-26 00:19:45.000000000 +1100
+++ ./MMTk/src/org/mmtk/plan/TraceLocal.java	2006-11-26 00:20:41.000000000 +1100
@@ -77,12 +77,12 @@
    * Trace a reference during GC.  This involves determining which
    * collection policy applies and calling the appropriate
    * <code>trace</code> method.
-   *
+   * @param srcObj TODO
    * @param objLoc The location containing the object reference to be
    * traced.  The object reference is <i>NOT</i> an interior pointer.
    * @param root True if <code>objLoc</code> is within a root.
    */
-  public final void traceObjectLocation(Address objLoc, boolean root)
+  public void traceObjectLocation(ObjectReference srcObj, Address objLoc, boolean root)
       throws InlinePragma {
     ObjectReference object = objLoc.loadObjectReference();
     ObjectReference newObject = traceObject(object, root);
@@ -94,13 +94,13 @@
    * collection policy applies and calling the appropriate
    * <code>trace</code> method.  This reference is presumed <i>not</i>
    * to be from a root.
-   *
+   * @param object TODO
    * @param objLoc The location containing the object reference to be
    * traced.  The object reference is <i>NOT</i> an interior pointer.
    */
-  public final void traceObjectLocation(Address objLoc)
+  public final void traceObjectLocation(ObjectReference srcObj, Address objLoc)
     throws InlinePragma {
-    traceObjectLocation(objLoc, false);
+    traceObjectLocation(srcObj, objLoc, false);
   }
 
   /**
@@ -159,7 +159,7 @@
    * 
    * @param object The object to be enqueued
    */
-  public final void enqueue(ObjectReference object) throws InlinePragma {
+  public void enqueue(ObjectReference object) throws InlinePragma {
     values.push(object);
   }
 
@@ -438,7 +438,7 @@
     logMessage(5, "processing root locations");
     while (!rootLocations.isEmpty()) {
       Address loc = rootLocations.pop();
-      traceObjectLocation(loc, true);
+      traceObjectLocation(null, loc, true);
     }
     logMessage(5, "processing interior root locations");
     while (!interiorRootLocations.isEmpty()) {
diff -r -N -w -u -I '[$]Id:' --exclude='*.class' --exclude='.*' --exclude='*.orig' --exclude='*.rej' --exclude=CVS --exclude='#*' --exclude='*~' ./MMTk/src/org/mmtk/utility/Log.java ./MMTk/src/org/mmtk/utility/Log.java
--- ./MMTk/src/org/mmtk/utility/Log.java	2006-11-26 00:19:45.000000000 +1100
+++ ./MMTk/src/org/mmtk/utility/Log.java	2006-11-26 00:20:41.000000000 +1100
@@ -212,22 +212,23 @@
       write("NaN");
       return;
     }
-    if (d > Integer.MAX_VALUE) {
+    if (d > Long.MAX_VALUE) {
       write("TooBig");
       return;
     }
-    if (d < -Integer.MAX_VALUE) {
+    if (d < -Long.MAX_VALUE) {
       write("TooSmall");
       return;
     }
 
     boolean negative = (d < 0.0);
-    d = (d < 0.0) ? (-d) : d;
-    int ones = (int) d;
+    d = negative ? (-d) : d;       // Take absolute value
+    long ones = (int) d;
     int multiplier = 1;
     while (postDecimalDigits-- > 0)
       multiplier *= 10;
     int remainder = (int) (multiplier * (d - ones));
+    if (remainder < 0) remainder = 0;
     if (negative) write('-');
     write(ones);
     write('.');
diff -r -N -w -u -I '[$]Id:' --exclude='*.class' --exclude='.*' --exclude='*.orig' --exclude='*.rej' --exclude=CVS --exclude='#*' --exclude='*~' ./MMTk/src/org/mmtk/utility/options/BooleanOption.java ./MMTk/src/org/mmtk/utility/options/BooleanOption.java
--- ./MMTk/src/org/mmtk/utility/options/BooleanOption.java	2006-11-26 00:19:45.000000000 +1100
+++ ./MMTk/src/org/mmtk/utility/options/BooleanOption.java	2006-11-26 00:20:41.000000000 +1100
@@ -72,4 +72,8 @@
     }
     validate();
   }
+  
+  /**
+   * Print the current value on standard output.
+   */
 }
diff -r -N -w -u -I '[$]Id:' --exclude='*.class' --exclude='.*' --exclude='*.orig' --exclude='*.rej' --exclude=CVS --exclude='#*' --exclude='*~' ./MMTk/src/org/mmtk/utility/options/CohortSize.java ./MMTk/src/org/mmtk/utility/options/CohortSize.java
--- ./MMTk/src/org/mmtk/utility/options/CohortSize.java	1970-01-01 10:00:00.000000000 +1000
+++ ./MMTk/src/org/mmtk/utility/options/CohortSize.java	2006-11-26 00:20:41.000000000 +1100
@@ -0,0 +1,41 @@
+/*
+ * (C) Copyright Department of Computer Science,
+ * Australian National University. 2004
+ */
+package org.mmtk.utility.options;
+
+import org.mmtk.utility.Constants;
+import org.mmtk.utility.statistics.Measurement;
+
+/**
+ * The granularity of the trace being produced.
+ *
+ * $Id: 02-measurement.patch,v 1.2 2006/07/19 04:12:18 steveb Exp $
+ *
+ * @author Daniel Frampton
+ * @version $Revision: 1.2 $
+ * @date $Date: 2006/07/19 04:12:18 $
+ */
+public class CohortSize extends PagesOption
+  implements org.mmtk.utility.Constants {
+  /**
+   * Create the option.
+   */
+  public CohortSize() {
+    super("Cohort Size",
+          "Size in bytes of a heap cohort (must be 2^n for some n)",
+          1 << (Constants.BITS_IN_INT - Constants.LOG_BYTES_IN_PAGE));
+  }
+
+  /**
+   * Trace rate must be positive.
+   */
+  protected void validate() {
+    int bytes = getBytes().toInt();
+    failIf(bytes < Measurement.MIN_COHORT_SIZE, "Cohort size less than minimum");
+    int logCohortSize;
+    for (logCohortSize = 0; bytes > (1<<logCohortSize); logCohortSize++)
+      ;
+    failIf(bytes != 1<<logCohortSize,"Cohort size must be a power of 2");
+  }
+}
diff -r -N -w -u -I '[$]Id:' --exclude='*.class' --exclude='.*' --exclude='*.orig' --exclude='*.rej' --exclude=CVS --exclude='#*' --exclude='*~' ./MMTk/src/org/mmtk/utility/options/HarnessWholeRun.java ./MMTk/src/org/mmtk/utility/options/HarnessWholeRun.java
--- ./MMTk/src/org/mmtk/utility/options/HarnessWholeRun.java	1970-01-01 10:00:00.000000000 +1000
+++ ./MMTk/src/org/mmtk/utility/options/HarnessWholeRun.java	2006-11-26 00:34:45.000000000 +1100
@@ -0,0 +1,25 @@
+/*
+ * (C) Copyright Department of Computer Science,
+ * Australian National University. 2004
+ */
+package org.mmtk.utility.options;
+
+/**
+ * Should a major GC be performed when a system GC is triggered?
+ * 
+ * $Id: X0-harnesshack.patch,v 1.1 2006/07/19 04:12:18 steveb Exp $
+ * 
+ * @author Daniel Frampton
+ * @version $Revision: 1.1 $
+ * @date $Date: 2006/07/19 04:12:18 $
+ */
+public class HarnessWholeRun extends BooleanOption {
+  /**
+   * Create the option.
+   */
+  public HarnessWholeRun() {
+    super("Harness Whole Run",
+          "Should we implicitly use the measurement harness for the whole run?",
+          false);
+  }
+}
diff -r -N -w -u -I '[$]Id:' --exclude='*.class' --exclude='.*' --exclude='*.orig' --exclude='*.rej' --exclude=CVS --exclude='#*' --exclude='*~' ./MMTk/src/org/mmtk/utility/options/Options.java ./MMTk/src/org/mmtk/utility/options/Options.java
--- ./MMTk/src/org/mmtk/utility/options/Options.java	2006-11-26 00:19:45.000000000 +1100
+++ ./MMTk/src/org/mmtk/utility/options/Options.java	2006-11-26 00:34:45.000000000 +1100
@@ -4,6 +4,10 @@
  */
 package org.mmtk.utility.options;
 
+import org.mmtk.utility.Log;
+
+import org.vmmagic.pragma.*;
+
 /**
  * Repository for all option instances.
  * 
@@ -20,6 +24,7 @@
 
   /* Other options */
   public static BoundedNursery boundedNursery;
+  public static CohortSize cohortSize;
   public static CycleFilterThreshold cycleFilterThreshold;
   public static CycleMetaDataLimit cycleMetaDataLimit;
   public static CycleTriggerThreshold cycleTriggerThreshold;
@@ -33,6 +38,7 @@
   public static GCspyWait gcspyWait;
   public static GCTimeCap gcTimeCap;
   public static GenCycleDetection genCycleDetection;
+  public static HarnessWholeRun harnessWholeRun;
   public static IgnoreSystemGC ignoreSystemGC;
   public static MarkSweepMarkBits markSweepMarkBits;
   public static MetaDataLimit metaDataLimit;
@@ -48,4 +54,41 @@
   public static VerboseFragmentationStats verboseFragmentationStats;
   public static Verbose verbose;
   public static VerboseTiming verboseTiming;
+  public static XmlStats xmlStats;
+  
+  public static void printOptionsXml() throws UninterruptibleNoWarnPragma {
+    Log.writeln("<options>");
+    Option opt = Option.getFirst();
+    while (opt != null) {
+      String key = opt.getKey();
+      Log.write("<option name=\""); Log.write(key); Log.write("\" value=\"");
+      String units = null;
+      switch (opt.getType()) {
+      case Option.BOOLEAN_OPTION:  
+        Log.write(((BooleanOption)opt).getValue()); break;
+      case Option.STRING_OPTION:   
+        Log.write(((StringOption)opt).getValue());  break;
+      case Option.ENUM_OPTION:     
+        Log.write(((EnumOption)opt).getValue());    break;
+      case Option.INT_OPTION:      
+        Log.write(((IntOption)opt).getValue());    break;
+      case Option.PAGES_OPTION:    
+        Log.write(((PagesOption)opt).getBytes());    
+        units = "bytes";                  break;
+      case Option.MICROSECONDS_OPTION: 
+        Log.write(((MicrosecondsOption)opt).getMicroseconds());    
+        units = "microseconds";           break;
+      case Option.FLOAT_OPTION:
+        Log.write(((FloatOption)opt).getValue());   break;
+      }
+      Log.write("\"");
+      if (units != null) {
+        Log.write(" units=\""); Log.write(units); Log.write("\"");
+      }
+      Log.writeln("/>");
+ 
+      opt = opt.getNext();
+    }
+    Log.writeln("</options>");
+  }
 }
diff -r -N -w -u -I '[$]Id:' --exclude='*.class' --exclude='.*' --exclude='*.orig' --exclude='*.rej' --exclude=CVS --exclude='#*' --exclude='*~' ./MMTk/src/org/mmtk/utility/options/XmlStats.java ./MMTk/src/org/mmtk/utility/options/XmlStats.java
--- ./MMTk/src/org/mmtk/utility/options/XmlStats.java	1970-01-01 10:00:00.000000000 +1000
+++ ./MMTk/src/org/mmtk/utility/options/XmlStats.java	2006-11-26 00:20:41.000000000 +1100
@@ -0,0 +1,9 @@
+package org.mmtk.utility.options;
+
+public class XmlStats extends BooleanOption {
+
+  public XmlStats() {
+    super("Xml Stats", "Print end-of-run statistics in XML format", false);
+  }
+
+}
diff -r -N -w -u -I '[$]Id:' --exclude='*.class' --exclude='.*' --exclude='*.orig' --exclude='*.rej' --exclude=CVS --exclude='#*' --exclude='*~' ./MMTk/src/org/mmtk/utility/scan/MMType.java ./MMTk/src/org/mmtk/utility/scan/MMType.java
--- ./MMTk/src/org/mmtk/utility/scan/MMType.java	2006-11-26 00:19:45.000000000 +1100
+++ ./MMTk/src/org/mmtk/utility/scan/MMType.java	2006-11-26 00:20:41.000000000 +1100
@@ -7,6 +7,8 @@
 
 import org.mmtk.utility.Constants;
 import org.mmtk.vm.ObjectModel;
+import org.mmtk.utility.Log;
+import org.mmtk.utility.statistics.Measurement;
 
 import org.vmmagic.unboxed.*;
 import org.vmmagic.pragma.*;
@@ -22,21 +24,29 @@
 public final class MMType implements Constants, Uninterruptible {
   // AJG: Maybe should make this immutable. See Item 13 of Effective Java.
   private boolean isReferenceArray;
+  private boolean isArray;
   private boolean isDelegated;
   private boolean isAcyclic;
-  private Offset arrayOffset;
+  private Offset arrayOffset = Offset.zero();
   private int[] offsets;
   private int allocator;
+  private final boolean hasBitmap;
+  private final Word bitmap;
+  private final byte[] name;
 
   // per-type statistics
   private int allocCount;
-  private int allocBytes;
+  private long allocBytes;
   private int copyCount;
   private int copyBytes;
   private int scanCount;
   private int scanBytes;
 
-  private static final boolean PROFILING_STATISTICS = false;
+//Link to the measurement plan
+  private int typeId = -1;
+
+  private static final boolean PROFILING_STATISTICS = true;
+  private static final int MAX_BITMAP_SIZE = 32;
 
   /****************************************************************************
    * 
@@ -54,14 +64,34 @@
    * @param offsets An array of integer offsets for the fields of this
    * type (if any).
    */
-  public MMType(boolean isDelegated, boolean isReferenceArray,
-      boolean isAcyclic, int allocator, int[] offsets)
+  public MMType(boolean isDelegated, boolean isReferenceArray, boolean isArray,
+                boolean isAcyclic, int allocator, int [] offsets, byte[] name)
       throws InterruptiblePragma {
     this.isDelegated = isDelegated;
     this.isReferenceArray = isReferenceArray;
+    this.isArray = isArray;
     this.isAcyclic = isAcyclic;
     this.allocator = allocator;
     this.offsets = offsets;
+    this.name = name;
+
+    // Build a bitmap if the object is compact enough and is not a reference array
+    if( offsets.length == 0 ) {
+      bitmap = Word.zero();
+      hasBitmap = !isReferenceArray;
+    } else if( (offsets[offsets.length-1] >> LOG_BYTES_IN_ADDRESS) + 1 < MAX_BITMAP_SIZE ) {
+      Word map = Word.zero();
+      for( int i=0; i < offsets.length; i++ ) {
+        map = map.or(Word.one().lsh((offsets[i]>>LOG_BYTES_IN_ADDRESS) + 1));
+      }
+      bitmap = map;
+      hasBitmap = true;
+    } else {
+      bitmap = Word.zero();
+      hasBitmap = false;
+    }
+
+    Measurement.resolvedClass(this);
   }
 
   /****************************************************************************
@@ -78,7 +108,7 @@
    * into an array
    * @return The address of the relevant slot within the object
    */
-  Address getSlot(ObjectReference object, int reference) throws InlinePragma {
+  public Address getSlot(ObjectReference object, int reference) throws InlinePragma {
     Address addr = object.toAddress();
     if (isReferenceArray)
       return addr.plus(arrayOffset).plus(reference << LOG_BYTES_IN_ADDRESS);
@@ -94,7 +124,7 @@
    * @param object The object in question
    * @return The number of references in the object
    */
-  int getReferences(ObjectReference object) throws InlinePragma {
+  public int getReferences(ObjectReference object) throws InlinePragma {
     if (isReferenceArray)
       return ObjectModel.getArrayLength(object);
     else
@@ -111,7 +141,7 @@
    * 
    * @param size The number of bytes allocated
    */
-  void profileAlloc(int size) throws InlinePragma {
+  public void profileAlloc(int size) throws InlinePragma {
     if (PROFILING_STATISTICS) {
       allocCount++;
       allocBytes += size;
@@ -148,13 +178,14 @@
    */
 
   /** @return True if scanning is delegated to the VM for this type */
-  boolean isDelegated() { return isDelegated; }
+  boolean isDelegated() throws InlinePragma { return isDelegated; }
 
   /** @return True if this type is an array of references */
   // FIXME made public so that GCspy drivers can determine whether
   // object is a reference array or not. Actually, we'like to do better
   // and distinguish arrays of primitives as well.
   public boolean isReferenceArray() { return isReferenceArray; }
+  public boolean isArray() { return isArray; }
 
   /** @return True if this type is known to be inherently acyclic */
   public boolean isAcyclic() { return isAcyclic; }
@@ -162,4 +193,20 @@
   /** @return The allocator to be used by default for this type */
   public int getAllocator() { return allocator; }
 
+  /** Accessor method for hasBitmap */
+  public boolean hasBitmap() throws InlinePragma { return hasBitmap; }
+
+  /** Accessor method for the bitmap */
+  public Word getBitmap() throws InlinePragma { return bitmap; }
+
+  /** Accessor method for typeId */
+  public int getTypeId() { return typeId; }
+  public void setTypeId(int typeId) { this.typeId = typeId; }
+  
+  /** Accessor method for the type name */
+  public byte[] getName() throws InlinePragma { return name; }
+
+  /** Accessor methods for allocation stats */
+  public int getAllocCount() { return allocCount; }
+  public long getAllocBytes() { return allocBytes; }
 }
diff -r -N -w -u -I '[$]Id:' --exclude='*.class' --exclude='.*' --exclude='*.orig' --exclude='*.rej' --exclude=CVS --exclude='#*' --exclude='*~' ./MMTk/src/org/mmtk/utility/scan/Scan.java ./MMTk/src/org/mmtk/utility/scan/Scan.java
--- ./MMTk/src/org/mmtk/utility/scan/Scan.java	2006-11-26 00:19:45.000000000 +1100
+++ ./MMTk/src/org/mmtk/utility/scan/Scan.java	2006-11-26 00:20:41.000000000 +1100
@@ -7,6 +7,7 @@
 package org.mmtk.utility.scan;
 
 import org.mmtk.plan.TraceLocal;
+import org.mmtk.utility.statistics.*;
 
 import org.mmtk.vm.ObjectModel;
 import org.mmtk.vm.Scanning;
@@ -36,7 +37,7 @@
       int references = type.getReferences(object);
       for (int i = 0; i < references; i++) {
         Address slot = type.getSlot(object, i);
-        trace.traceObjectLocation(slot);
+        trace.traceObjectLocation(object, slot);
       }
     } else
       Scanning.scanObject(trace, object);
diff -r -N -w -u -I '[$]Id:' --exclude='*.class' --exclude='.*' --exclude='*.orig' --exclude='*.rej' --exclude=CVS --exclude='#*' --exclude='*~' ./MMTk/src/org/mmtk/utility/statistics/Accumulator.java ./MMTk/src/org/mmtk/utility/statistics/Accumulator.java
--- ./MMTk/src/org/mmtk/utility/statistics/Accumulator.java	1970-01-01 10:00:00.000000000 +1000
+++ ./MMTk/src/org/mmtk/utility/statistics/Accumulator.java	2006-11-26 00:20:41.000000000 +1100
@@ -0,0 +1,28 @@
+package org.mmtk.utility.statistics;
+
+import org.vmmagic.pragma.*;
+
+public class Accumulator implements Uninterruptible {
+
+  private long count = 0;
+  private double sum = 0;
+  private double sum_sqd = 0;
+  
+  public void add(double point) {
+    count++;
+    sum += point;
+    sum_sqd += point * point;
+  }
+  
+  public void reset() {
+    count = 0;
+    sum = sum_sqd = 0;
+  }
+  
+  public long getCount() { return count; }
+  public double getSum() { return sum; }
+  public double getMean() { return sum/count; }
+  public double getVariance() {
+    return sum_sqd/count - getMean() * getMean();
+  }
+}
diff -r -N -w -u -I '[$]Id:' --exclude='*.class' --exclude='.*' --exclude='*.orig' --exclude='*.rej' --exclude=CVS --exclude='#*' --exclude='*~' ./MMTk/src/org/mmtk/utility/statistics/Counter.java ./MMTk/src/org/mmtk/utility/statistics/Counter.java
--- ./MMTk/src/org/mmtk/utility/statistics/Counter.java	2006-11-26 00:19:45.000000000 +1100
+++ ./MMTk/src/org/mmtk/utility/statistics/Counter.java	2006-11-26 00:20:41.000000000 +1100
@@ -26,6 +26,7 @@
   private String name;
   private boolean start;
   private boolean mergephases;
+  protected boolean complex = false;
 
   /****************************************************************************
    * 
@@ -161,4 +162,6 @@
    * @return True if this counter will merge stats for GC and mutator phases.
    */
   boolean mergePhases() { return mergephases; }
+
+  boolean isComplex() { return complex; }
 }
diff -r -N -w -u -I '[$]Id:' --exclude='*.class' --exclude='.*' --exclude='*.orig' --exclude='*.rej' --exclude=CVS --exclude='#*' --exclude='*~' ./MMTk/src/org/mmtk/utility/statistics/Histogram.java ./MMTk/src/org/mmtk/utility/statistics/Histogram.java
--- ./MMTk/src/org/mmtk/utility/statistics/Histogram.java	1970-01-01 10:00:00.000000000 +1000
+++ ./MMTk/src/org/mmtk/utility/statistics/Histogram.java	2006-11-26 00:24:35.000000000 +1100
@@ -0,0 +1,172 @@
+/**
+ * (C) Copyright Department of Computer Science,
+ * Australian National University. 2005
+ */
+package org.mmtk.utility.statistics;
+
+import org.mmtk.utility.Log;
+import org.mmtk.vm.Assert;
+
+import org.vmmagic.pragma.*;
+
+/**
+ * @author Robin Garner
+ *
+ */
+public class Histogram extends Counter implements Uninterruptible {
+
+  private final int[] buckets;
+  private final long[] counts;
+  private final long[] sums;
+  private boolean running = false;
+  
+  /**
+   * @param name Name of the counter
+   * @param buckets The thresholds for the histogram buckets
+   */
+  public Histogram(String name, int[] buckets) {
+    super(name);
+    this.complex = true;
+    this.buckets = buckets;
+    this.counts = new long[buckets.length+1];
+    this.sums = new long[buckets.length+1];
+    Assert._assert(false,"Histograms do not support mutator/GC phases yet");
+  }
+
+  /**
+   * @param name
+   * @param start
+   */
+  public Histogram(String name, int[] buckets, boolean start) {
+    super(name, start);
+    this.complex = true;
+    this.buckets = buckets;
+    this.counts = new long[buckets.length+1];
+    this.sums = new long[buckets.length+1];
+    Assert._assert(false,"Histograms do not support mutator/GC phases yet");
+  }
+
+  /**
+   * @param name
+   * @param start
+   * @param mergephases
+   */
+  public Histogram(String name, int[] buckets, boolean start, boolean mergephases) {
+    super(name, start, mergephases);
+    this.complex = true;
+    this.buckets = buckets;
+    this.counts = new long[buckets.length+1];
+    this.sums = new long[buckets.length+1];
+  }
+
+  void reset() {
+    for (int i=0; i < counts.length; i++) {
+      counts[i] = 0;
+      sums[i] = 0;
+    }
+  }
+  
+  /**
+   * Add a value to the histogram.
+   * 
+   * @param value The value to add.
+   */
+  public void add(int value) {
+    if (running) {
+      for (int i=0; i <= buckets.length; i++) {
+        if (i == buckets.length || buckets[i] >= value) {
+          counts[i]++;
+          sums[i] += value;
+          break;
+        }
+      }
+    }
+  }
+
+  /**
+   * @see org.mmtk.utility.statistics.Counter#start()
+   */
+  void start() {
+    running = true;
+  }
+
+  /**
+   * @see org.mmtk.utility.statistics.Counter#stop()
+   */
+  void stop() {
+    running = false;
+  }
+
+  /* (non-Javadoc)
+   * @see org.mmtk.utility.statistics.Counter#phaseChange(int)
+   */
+  void phaseChange(int oldPhase) {
+    // We don't support phases yet
+  }
+
+  /* (non-Javadoc)
+   * @see org.mmtk.utility.statistics.Counter#printCount(int)
+   */
+  void printCount(int phase) {
+    // TODO Auto-generated method stub
+
+  }
+
+  /* (non-Javadoc)
+   * @see org.mmtk.utility.statistics.Counter#printTotal()
+   */
+  void printTotal() {
+    // TODO Auto-generated method stub
+
+  }
+
+  /* (non-Javadoc)
+   * @see org.mmtk.utility.statistics.Counter#printTotal(boolean)
+   */
+  void printTotal(boolean mutator) {
+    // TODO Auto-generated method stub
+
+  }
+
+  /* (non-Javadoc)
+   * @see org.mmtk.utility.statistics.Counter#printMin(boolean)
+   */
+  void printMin(boolean mutator) {
+    // TODO Auto-generated method stub
+
+  }
+
+  /* (non-Javadoc)
+   * @see org.mmtk.utility.statistics.Counter#printMax(boolean)
+   */
+  void printMax(boolean mutator) {
+    // TODO Auto-generated method stub
+
+  }
+
+  /**
+   * Print the table of accumulated values
+   * 
+   * Don't print buckets with zero values.
+   */
+  void printTable() {
+    XmlMeasure.openTag(getName(),true);
+    int last = 0;
+    for (int i=0; i < buckets.length; i++) {
+      Xml.openMinorTag("bucket");
+      Xml.attribute("low", last); 
+      Xml.attribute("high",buckets[i]);
+      Xml.attribute("count",counts[i]);
+      Xml.attribute("sum",sums[i]);
+      Xml.closeMinorTag();
+      last = buckets[i];
+    }
+    Xml.openMinorTag("bucket");
+    Xml.attribute("low", last); 
+    Xml.attribute("high",Integer.MAX_VALUE);
+    Xml.attribute("count",counts[buckets.length]);
+    Xml.attribute("sum",sums[buckets.length]);
+    Xml.closeMinorTag();
+    Xml.closeTag();
+  }
+}
diff -r -N -w -u -I '[$]Id:' --exclude='*.class' --exclude='.*' --exclude='*.orig' --exclude='*.rej' --exclude=CVS --exclude='#*' --exclude='*~' ./MMTk/src/org/mmtk/utility/statistics/LogHistogram.java ./MMTk/src/org/mmtk/utility/statistics/LogHistogram.java
--- ./MMTk/src/org/mmtk/utility/statistics/LogHistogram.java	1970-01-01 10:00:00.000000000 +1000
+++ ./MMTk/src/org/mmtk/utility/statistics/LogHistogram.java	2006-11-26 00:20:41.000000000 +1100
@@ -0,0 +1,49 @@
+package org.mmtk.utility.statistics;
+
+public class LogHistogram extends Histogram {
+
+  private static int[] genBuckets(int logMax) {
+    int[] result = new int[2*(logMax+1)+2];
+    int lowBound = Integer.MIN_VALUE;
+    int highBound = -(1<<logMax);
+    int i=0;
+    while (highBound < 0) {
+      result[i++] = lowBound;
+      lowBound = highBound;
+      highBound /= 2;
+    }
+    result[i++] = -1;
+    lowBound = 0;
+    highBound = 1;
+    while (lowBound <= (1<<logMax)) {
+      result[i++] = lowBound;
+      lowBound = highBound;
+      highBound <<= 1;
+    }
+    return result;
+  }
+  
+  public static void main(String[] args) {
+    int[] x = genBuckets(Integer.parseInt(args[0]));
+    for (int i=0; i < x.length; i++) {
+      System.out.println(i+" "+x[i]);
+    }
+  }
+  
+  public LogHistogram(String name, int logMax) {
+    super(name, genBuckets(logMax));
+    // TODO Auto-generated constructor stub
+  }
+
+  public LogHistogram(String name, int[] buckets, boolean start) {
+    super(name, buckets, start);
+    // TODO Auto-generated constructor stub
+  }
+
+  public LogHistogram(String name, int[] buckets, boolean start,
+      boolean mergephases) {
+    super(name, buckets, start, mergephases);
+    // TODO Auto-generated constructor stub
+  }
+
+}
diff -r -N -w -u -I '[$]Id:' --exclude='*.class' --exclude='.*' --exclude='*.orig' --exclude='*.rej' --exclude=CVS --exclude='#*' --exclude='*~' ./MMTk/src/org/mmtk/utility/statistics/Measurement.java ./MMTk/src/org/mmtk/utility/statistics/Measurement.java
--- ./MMTk/src/org/mmtk/utility/statistics/Measurement.java	1970-01-01 10:00:00.000000000 +1000
+++ ./MMTk/src/org/mmtk/utility/statistics/Measurement.java	2006-11-26 00:20:41.000000000 +1100
@@ -0,0 +1,869 @@
+/*
+ * (C) Copyright Department of Computer Science,
+ * Australian National University. 2003
+ */
+package org.mmtk.utility.statistics;
+
+import org.mmtk.plan.Plan;
+import org.mmtk.policy.Space;
+import org.mmtk.utility.Log;
+import org.mmtk.utility.scan.MMType;
+import org.mmtk.utility.options.Options;
+import org.mmtk.utility.Constants;
+
+import org.mmtk.vm.Assert;
+import org.mmtk.vm.ObjectModel;
+import org.mmtk.vm.ActivePlan;
+
+import org.vmmagic.pragma.*;
+import org.vmmagic.unboxed.*;
+
+/*
+ * @author Fahad Gilani
+ * @author <a href="http://cs.anu.edu.au/~Steve.Blackburn">Steve Blackburn</a>
+ * @author <a href="http://cs.anu.edu.au/~Robin.Garner">Robin Garner</a>
+ *
+ * @version $Revision: 1.2 $
+ * @date $Date: 2006/07/19 04:12:18 $
+ */
+public class Measurement implements Constants, Uninterruptible {
+  
+  /* Do reference counting */
+  public static final boolean MEASURE_REFS = true;
+
+  private static final int[] ALLOC_BUCKETS_FINE = new int[] { 
+    0,      4,      8,     12,     
+    16,     20,     24,     32,     36,     40,     44,     48,     52,     56,     60,     64,  // Step by 4
+    80,     96,    112,    128,    144,    160,    176,    192,    208,    224,    240,    256,  // Step by 16
+    330,    396,    460,    512,    576,    640,    704,    768,    832,    896,    960,   1024,  // Step by 64
+    1280,   1536,   1792,   2048,   2304,   2560,   2816,   3072,   3328,   3584,   3840,   4096,  // Step by 256
+    5120,   6144,   7168,   8192,   9216,  10240,  11264,  12288,  13312,  14336,  15360,  16384,  // Step by 1024
+    20480,  24576,  28672,  32768,  36864,  40960,  45056,  49152,  53248,  57344,  61440,  65536,  // Step by 4096
+    81920,  98304, 114688, 131072, 147456, 163840, 180224, 196608, 212992, 229376, 245760, 262144,  // Step by 16K
+    327680, 393216, 458752, 524288, 589824, 655360, 720896, 786432, 851968, 917504, 983040,1048576,  // Step by 64K
+    1310720,1572864,1835008,2097152,2359296,2621440,2883584,3145728,3407872,3670016,3932160,4194304   // Step by 256K
+  };
+  private static final int[] ALLOC_BUCKETS_COARSE = new int[] { 
+    0,      
+    4,      8,     12,     16,     20,     24,     32,             // Step by 4
+    36,     40,     44,     48,     52,     56,     60,
+    64,    128,    192,    256,    330,    396,    460,             // Step by 64
+    512,    576,   640,    704,    768,    832,    896,    960,   
+    1024,  2048,   3072,   4096,   5120,   6144,   7168,            // Step by 1K
+    8192,   9216, 10240,  11264,  12288,  13312,  14336,  15360,  
+    16384, 32768,  49152, 65536,  98304, 114688, 131072,            // Step by 16K
+    147456, 163840, 180224, 196608, 212992, 229376, 245760, 
+    262144,  524288, 786432, 1048576                                // Step by 256K
+  };
+  public static final int[] ALLOC_BUCKETS = ALLOC_BUCKETS_COARSE;
+  
+  private static final int verbose = 0;
+  public static final boolean MEASURE_DETAIL = true;
+  public static final int MEASUREMENT_HEADER_WORDS = 
+    (MEASURE_DETAIL ? 2 : 0) + (MEASURE_REFS ? 2 : 0);
+  public static final int MEASUREMENT_HEADER_BYTES = 
+    MEASUREMENT_HEADER_WORDS * BYTES_IN_WORD;
+
+  public static final int LOG_MIN_COHORT_SIZE = 10;                  // 4KB
+  public static final int MIN_COHORT_SIZE = 1<<LOG_MIN_COHORT_SIZE;  // 64KB
+  private static final long MAX_ALLOCATION = (1L << 36) - 1;           // 32GB XXX
+  private static final int MAX_COHORTS = 1<<18;
+  private static final int POINTER_LOC_BUCKETS = LOG_BYTES_IN_ADDRESS_SPACE+1;
+  private static final int POINTER_DISTANCE_ZERO_BUCKET = POINTER_LOC_BUCKETS;
+  private static final int POINTER_DIST_BUCKETS = (2*POINTER_LOC_BUCKETS) + 1;
+  
+  private static final int MAX_TYPES = 1<<16;                        // Track this many classes
+  
+  private static final long NULL_BIRTHDATE = 0;
+  
+  private static final int[] POINTER_BUCKETS_FINE = new int[] {
+       0,    1,    2,    3,    4,     
+       5,    6,    7,    8,    9,   10,   11,   12,   13,   14,   15,   16, 
+      20,   24,   28,   32,   36,   40,   44,   48,   52,   56,   60,   64,
+      80,   96,  112,  128,  144,  160,  176,  192,  208,  224,  240,  256,
+     330,  396,  460,  512,  576,  640,  704,  768,  832,  896,  960, 1024,  // Step by 64
+    1280, 1536, 1792, 2048, 2304, 2560, 2816, 3072, 3328, 3584, 3840, 4096,  // Step by 256
+  };
+  private static final int[] POINTER_BUCKETS_COARSE = new int[] {
+    0,    1,    2,    3,    4,     
+    5,    6,    7,    8,    10,   12,   14,   16, 
+   24,   32,   40,   48,   56,   64,
+   96,  128,  160,  192,  224,  256,
+  396,  512,  640,  768,  896, 1024,  // Step by 128
+ 1536, 2048, 2560, 3072, 3584, 4096,  // Step by 512
+};
+  private static final int[] POINTER_BUCKETS = POINTER_BUCKETS_COARSE;
+
+  /**
+   * Turn measurement on or off - for example to measure 
+   * the nth run of a benchmark
+   */
+  public static boolean measuring = false;
+  
+  /**
+   * Set to false after the first GC while measuring
+   */
+  private static boolean firstGc = true;
+  
+  private static int collections = 0;
+  
+  // allocation cohorts
+  private static int[] cohortLiveObjects;
+  private static int[] cohortLiveBytes;
+  private static long[] cohortHeapPosition;
+  private static int totalCohorts;
+  private static int totalLiveBytes;
+  private static int totalLiveObjects;
+  private static int maxLiveObjects = 0;
+  private static int maxLiveBytes = 0;
+  private static int currentLiveBytes;                   // Bytes live counted during GC
+  private static int currentLiveObjects;                 // Objects live counted during GC
+  private static long sumLiveBytes = 0;                  // Cumulative count of live bytes
+  private static long sumLiveObjects = 0;                // Cumulative count of live objects
+  private static int logCohortSize;
+  private static long cohortSize;
+  private static long totalBytesAllocated = 0;
+  private static long totalObjectsAllocated = 0;
+  private static long arrayBytesAllocated = 0;
+  private static long totalArraysAllocated = 0;
+  private static long greenBytesAllocated = 0;
+  private static long totalGreenObjectsAllocated = 0;
+  private static long lastGCBirthdate = 0;
+  private static long lastGCPerfectBirthdate = 0;
+  
+  /* Allow average pointer stats */
+  private static Accumulator outgoingPointerStats = new Accumulator();
+  private static Accumulator incomingPointerStats = new Accumulator();
+  private static long roots = 0;
+
+  // pointer mutations
+  private static long totalMutations = 0;
+  private static long totalNonNullMutations = 0;
+  private static long[] mutationSrcHistogram;
+  private static long[] mutationTgtHistogram;
+  private static long[] mutationDistanceHistogram;
+  private static long[] perfectMutationSrcHistogram;
+  private static long[] perfectMutationTgtHistogram;
+  private static long[] perfectMutationDistanceHistogram;
+
+  // pointers (as at GC time)
+  private static long totalPointers = 0;
+  private static long[] pointerSrcHistogram;
+  private static long[] pointerTgtHistogram;
+  private static long[] pointerDistanceHistogram;
+  private static long[] perfectPointerSrcHistogram;
+  private static long[] perfectPointerTgtHistogram;
+  private static long[] perfectPointerDistanceHistogram;
+
+  /** Allocation statistics */
+  private static Histogram allocations = new Histogram("allocations",ALLOC_BUCKETS,true,true);
+  private static Histogram arrayAllocations = new Histogram("arrayAllocations",ALLOC_BUCKETS,true,true);
+  private static Histogram greenAllocations = new Histogram("greenAllocations",ALLOC_BUCKETS,true,true);
+  private static Histogram liveSizes = new Histogram("liveSizes",ALLOC_BUCKETS,true,true);
+  private static Histogram liveArraySizes = new Histogram("liveArraySizes",ALLOC_BUCKETS,true,true);
+  private static Histogram liveGreenSizes = new Histogram("liveGreenSizes",ALLOC_BUCKETS,true,true);
+  private static Histogram currentAllocations = new Histogram("currentAllocations",ALLOC_BUCKETS,true,true);
+  private static Histogram currentLiveSizes = new Histogram("currentLiveSizes",ALLOC_BUCKETS,true,true);
+  private static Histogram currentArrayAllocations = new Histogram("currentArrayAllocations",ALLOC_BUCKETS,true,true);
+  private static Histogram currentLiveArraySizes = new Histogram("currentLiveArraySizes",ALLOC_BUCKETS,true,true);
+  private static Histogram currentGreenAllocations = new Histogram("currentGreenAllocations",ALLOC_BUCKETS,true,true);
+  private static Histogram currentLiveGreenSizes = new Histogram("currentLiveGreenSizes",ALLOC_BUCKETS,true,true);
+  
+  /** Pointer statistics */
+  private static Histogram scalarPointers = new Histogram("scalarPointers",POINTER_BUCKETS,true,true);
+  private static Histogram arrayPointers = new Histogram("arrayPointers",POINTER_BUCKETS,true,true);
+  private static Histogram liveScalarPointers = new Histogram("liveScalarPointers",POINTER_BUCKETS,true,true);
+  private static Histogram liveArrayPointers = new Histogram("liveArrayPointers",POINTER_BUCKETS,true,true);
+  private static Histogram incomingPointers = new Histogram("incomingPointers",POINTER_BUCKETS,true,true);
+  private static Histogram outgoingPointers = new Histogram("outgoingPointers",POINTER_BUCKETS,true,true);
+  
+  private static Histogram currentScalarPointers = new Histogram("currentScalarPointers",POINTER_BUCKETS,true,true);
+  private static Histogram currentArrayPointers = new Histogram("currentArrayPointers",POINTER_BUCKETS,true,true);
+  private static Histogram currentLiveScalarPointers = new Histogram("currentLiveScalarPointers",POINTER_BUCKETS,true,true);
+  private static Histogram currentLiveArrayPointers = new Histogram("currentLiveArrayPointers",POINTER_BUCKETS,true,true);
+  private static Histogram currentIncomingPointers = new Histogram("currentIncomingPointers",POINTER_BUCKETS,true,true);
+  private static Histogram currentOutgoingPointers = new Histogram("currentOutgoingPointers",POINTER_BUCKETS,true,true);
+  
+  /** Per-type statistics */
+  private static ObjectReferenceArray types;
+  private static int maxType = 0;
+  
+  private static Accumulator mutationDistance = new Accumulator(); 
+  private static Accumulator pointerDistance = new Accumulator(); 
+
+  static {
+    cohortLiveObjects = new int[MAX_COHORTS];
+    cohortLiveBytes = new int[MAX_COHORTS];
+    cohortHeapPosition = new long[MAX_COHORTS];
+
+    mutationSrcHistogram = new long[POINTER_LOC_BUCKETS];
+    mutationTgtHistogram = new long[POINTER_LOC_BUCKETS];
+    mutationDistanceHistogram = new long[POINTER_DIST_BUCKETS];
+    perfectMutationSrcHistogram = new long[POINTER_LOC_BUCKETS];
+    perfectMutationTgtHistogram = new long[POINTER_LOC_BUCKETS];
+    perfectMutationDistanceHistogram = new long[POINTER_DIST_BUCKETS];
+
+    pointerSrcHistogram = new long[POINTER_LOC_BUCKETS];
+    pointerTgtHistogram = new long[POINTER_LOC_BUCKETS];
+    pointerDistanceHistogram = new long[POINTER_DIST_BUCKETS];
+    perfectPointerSrcHistogram = new long[POINTER_LOC_BUCKETS];
+    perfectPointerTgtHistogram = new long[POINTER_LOC_BUCKETS];
+    perfectPointerDistanceHistogram = new long[POINTER_DIST_BUCKETS];
+    
+    types = ObjectReferenceArray.create(MAX_TYPES);
+  }
+
+  /**
+   * The system is up and running.  Perform basic initialization
+   */
+  public static final void boot() {
+    // Calculate the log of the cohort size
+    cohortSize = Options.cohortSize.getBytes().toInt();
+    for (logCohortSize = LOG_MIN_COHORT_SIZE; cohortSize > (1<<logCohortSize); logCohortSize++)
+      ;
+  }
+
+  public static final void start() {
+    measuring = true;
+    if (verbose >= 1) Log.writeln("Measurement enabled");
+  }
+
+  public static final void stop() {
+    measuring = false;
+    if (verbose >= 1) Log.writeln("Measurement disabled");
+  }
+
+
+  /**
+   * A reference array copy has occured, perform appropriate
+   * bookkeeping. 
+   * 
+   * @param src The first word to be copied
+   * @param tgt The mutated object
+   * @param bytes The number of bytes to be copied
+   */
+  public static final void pointerMutations(ObjectReference src, ObjectReference tgt,
+					    int bytes) {
+    Address cursor = src.toAddress();
+    Address slot = tgt.toAddress();
+    while (bytes > 0) {
+      pointerMutation(tgt, slot, cursor.loadObjectReference());
+      cursor = cursor.plus(BYTES_IN_ADDRESS);
+      slot = slot.plus(BYTES_IN_ADDRESS);
+      bytes -= BYTES_IN_ADDRESS;
+    }
+  }
+
+
+  /**
+   * A pointer has been mutated, perform appropriate bookkeeping.
+   * This should be called each time a pointer is mutated.
+   * 
+   * @param src The object containing the mutated pointer
+   * @param tgt The object pointed to
+   */
+  public static final void pointerMutation(ObjectReference src, Address slot, ObjectReference tgt)
+  throws NoInlinePragma {
+    if (measuring && ActivePlan.mutator().currentScope == Plan.DEFAULT_SCOPE) {
+      if (Assert.VERIFY_ASSERTIONS) Assert._assert(!src.isNull());
+      if (verbose >= 5) Log.writeln("Pointer mutation");
+      long srcBD = getBirthdate(src);
+      if (srcBD != NULL_BIRTHDATE) {
+        totalMutations++;
+        if (!tgt.isNull()) {
+          totalNonNullMutations++;
+          long tgtBD = getBirthdate(tgt);
+          long srcPerfectBD = getPerfectBirthdate(srcBD);
+          long tgtPerfectBD = getPerfectBirthdate(tgtBD);
+          mutationSrcHistogram[getLocationBucket(srcBD, false)]++;
+          mutationTgtHistogram[getLocationBucket(tgtBD, false)]++;
+          mutationDistanceHistogram[getDistanceBucket(srcBD, tgtBD)]++;
+          perfectMutationSrcHistogram[getLocationBucket(srcPerfectBD, true)]++;
+          perfectMutationTgtHistogram[getLocationBucket(tgtPerfectBD, true)]++;
+          perfectMutationDistanceHistogram[getDistanceBucket(srcPerfectBD, tgtPerfectBD)]++;
+          mutationDistance.add(getLogDistance(srcPerfectBD, tgtPerfectBD));
+        }
+        if (verbose >= 5) Log.writeln("Pointer mutation logged");
+      }
+    }
+  }
+  
+  /**
+   * A pointer is live at GC time, perform appropriate bookkeeping.
+   * This should be called exactly once at each GC for each pointer in
+   * the graph of live objects.
+   * 
+   * We ignore pointers from objects with a null birthday, as these are
+   * either VM or compiler-generated objects.  The application being
+   * measured shouldn't be able to point to the VM !
+   * 
+   * @param src The object containing the mutated pointer
+   * @param tgt The object pointed to
+   */
+  public static final void livePointer(ObjectReference src, ObjectReference tgt)
+  throws NoInlinePragma {
+    long srcBD = getBirthdate(src);
+    if (srcBD != NULL_BIRTHDATE) {
+      totalPointers++;
+      if (Assert.VERIFY_ASSERTIONS) Assert._assert(!src.isNull());
+      if (!tgt.isNull()) {
+        if (verbose >= 4) Log.writeln("Logging live pointer");
+        long tgtBD = getBirthdate(tgt);
+        long srcPerfectBD = getPerfectBirthdate(srcBD);
+        long tgtPerfectBD = getPerfectBirthdate(tgtBD);
+        pointerSrcHistogram[getLocationBucket(srcBD, false)]++;
+        pointerTgtHistogram[getLocationBucket(tgtBD, false)]++;
+        pointerDistanceHistogram[getDistanceBucket(srcBD, tgtBD)]++;
+        perfectPointerSrcHistogram[getLocationBucket(srcPerfectBD, true)]++;
+        perfectPointerTgtHistogram[getLocationBucket(tgtPerfectBD, true)]++;
+        perfectPointerDistanceHistogram[getDistanceBucket(srcPerfectBD, tgtPerfectBD)]++;
+        pointerDistance.add(getLogDistance(srcPerfectBD, tgtPerfectBD));
+        
+        incRefCount(tgt);
+        if (verbose >= 4) Log.writeln("Logging live pointer - done");
+      }
+    }
+  }
+  
+  public static void resolvedClass(MMType type) {
+    if (measuring && ActivePlan.mutator().currentScope == Plan.DEFAULT_SCOPE) {
+      newType(type);
+    }
+  }
+
+  /**
+   * @param type
+   */
+  private static int newType(MMType type) {
+    int id = maxType++;
+    type.setTypeId(id);
+    types.set(id,ObjectReference.fromObject(type));
+    return id;
+  }
+
+  /**
+   * An object has been created, perform appropriate bookkeeping.
+   * This should be called each time an object is created.
+   *
+   * @param object The newly created object
+   * @param bytes The size of the new object in bytes
+   */
+  public static final void objectCreation(ObjectReference object, int bytes) 
+    throws NoInlinePragma {
+    
+    resetRefCount(object);
+    if (!measuring ||
+        ActivePlan.mutator().currentScope != Plan.DEFAULT_SCOPE ||
+        Space.isInSpace(Plan.VM, object)) {
+      ObjectModel.setBirthdate(object, NULL_BIRTHDATE);
+    } else {
+      if (Assert.VERIFY_ASSERTIONS) Assert._assert(!object.isNull());
+      if (verbose >= 3) Log.writeln("Logging object creation");
+
+      /* Maintain the table of class descriptions */
+      MMType type = ObjectModel.getObjectType(object);
+     if (type.getTypeId() == -1)
+        newType(type);
+      
+      bytes -= MEASUREMENT_HEADER_BYTES;
+      if (totalBytesAllocated > MAX_ALLOCATION - bytes)
+        Assert.fail("Maximum allocation exceeded");
+      totalBytesAllocated += bytes;
+      totalObjectsAllocated++;
+      allocations.add(bytes);
+      currentAllocations.add(bytes);
+      if (type.isArray()) { 
+        arrayBytesAllocated += bytes;
+        totalArraysAllocated++;
+        arrayAllocations.add(bytes);
+        currentArrayAllocations.add(bytes);
+      }
+      if (type.isAcyclic()) { 
+        greenBytesAllocated += bytes;
+        totalGreenObjectsAllocated++;
+        greenAllocations.add(bytes);
+        currentGreenAllocations.add(bytes);
+      }
+      int cohort = getCohortFromBirthdate(totalBytesAllocated);
+      if (cohort > MAX_COHORTS)
+        Assert.fail("Maximum cohorts exceeded - rerun with a larger cohort size");
+      totalLiveBytes += bytes;
+      totalLiveObjects++;
+      cohortLiveBytes[cohort] += bytes;
+      totalCohorts = cohort + 1;
+      ObjectModel.setBirthdate(object, now());
+      if (Assert.VERIFY_ASSERTIONS) {
+        long bday = ObjectModel.getBirthdate(object);
+        if (bday != now()) {
+          Log.write("now() "); Log.write(now()); Log.write(" bday "); Log.writeln(bday);
+        }
+        Assert._assert(bday == now());
+      }
+      if (verbose >= 3) { 
+        Log.write("Logging object creation - done "); Log.writeln(totalObjectsAllocated);
+      }
+      
+      // Per-class statistics
+      type.profileAlloc(bytes);
+      
+      // Pointer statistics
+      if (type.isReferenceArray()) {
+        arrayPointers.add(type.getReferences(object));
+        currentArrayPointers.add(type.getReferences(object));
+      } else {
+        scalarPointers.add(type.getReferences(object));
+        currentScalarPointers.add(type.getReferences(object));
+      }
+    }
+  }
+
+  /**
+   * An object is live at GC time, perform appropriate bookkeeping.
+   * This should be called exactly once at each GC for each object in
+   * the graph of live objects.
+   * 
+   * The hooks in the measurement collector ensure that this is called
+   * before any of the outgoing pointers are processed.
+   *
+   * @param object The live object
+   * @param bytes The size (in bytes) of the live object
+   */
+  public static final void liveObject(ObjectReference object, int bytes) 
+    throws NoInlinePragma {
+    long birthdate = getBirthdate(object);
+    if (birthdate != NULL_BIRTHDATE) {
+      bytes -= MEASUREMENT_HEADER_BYTES;
+      liveSizes.add(bytes);
+      currentLiveSizes.add(bytes);
+      currentLiveBytes += bytes;
+      currentLiveObjects++;
+      int cohort = getCohortFromBirthdate(birthdate);
+      cohortLiveBytes[cohort] += bytes;
+      cohortLiveObjects[cohort]++;
+      
+      // Pointer distribution at GC time
+      MMType type = ObjectModel.getObjectType(object);
+      
+      if (type.isArray()) {
+        liveArraySizes.add(bytes);
+        currentLiveArraySizes.add(bytes);
+      }
+
+      if (type.isAcyclic()) {
+        liveGreenSizes.add(bytes);
+        currentLiveGreenSizes.add(bytes);
+      }
+
+      // Pointer statistics
+      if (type.isReferenceArray()) {
+        liveArrayPointers.add(type.getReferences(object));
+        currentLiveArrayPointers.add(type.getReferences(object));
+      } else {
+        liveScalarPointers.add(type.getReferences(object));
+        currentLiveScalarPointers.add(type.getReferences(object));
+      }
+
+      /*
+       * Track pointer-graph shape statistics, reference count and 
+       * outgoing pointer count, stored during the last GC
+       */
+      boolean touched = touched(object);
+      int refcount = resetRefCount(object);
+      if (!firstGc) {  // Ignore first GC
+        if (refcount == 0)
+          roots++;
+        if (touched) {
+          incomingPointerStats.add(refcount);
+          incomingPointers.add(refcount);
+          currentIncomingPointers.add(refcount);
+
+          int pointers = ObjectModel.getPtrcount(object);
+          currentOutgoingPointers.add(pointers);
+          outgoingPointers.add(pointers);
+          outgoingPointerStats.add(pointers);
+        }
+      }
+
+      /* 
+       * Save the non-null pointers in the object header, to read out next GC
+       * along with the reference count
+       */
+      int pointers = 0;
+      for (int i=0; i < type.getReferences(object); i++)
+        if (!type.getSlot(object,i).loadObjectReference().isNull())
+          pointers++;
+      ObjectModel.setPtrcount(object, pointers);
+    }
+  }
+
+  /**
+   * A collection is about to commence.  Clear counters.
+   */
+  public static final void gcStart() {
+    collections++;
+    for (int c = 0; c <= totalCohorts; c++) {
+      cohortLiveObjects[c] = 0;
+      cohortLiveBytes[c] = 0;
+    }
+    currentLiveObjects = 0;
+    currentLiveBytes = 0;
+  }
+
+  /**
+   * A collection has completed.  Perform appropriate bookkeeping and
+   * output statistics as necessary.
+   */
+  public static final void gcEnd() {
+    if (measuring) {
+      Xml.begin();
+      XmlMeasure.openTag("collection",true);
+      totalLiveBytes = currentLiveBytes;                  
+      totalLiveObjects = currentLiveObjects;              
+      maxLiveBytes = maxLiveBytes > currentLiveBytes ?
+              maxLiveBytes : currentLiveBytes;
+      maxLiveObjects = maxLiveObjects > currentLiveObjects ?
+              maxLiveObjects : currentLiveObjects;
+      sumLiveBytes += currentLiveBytes;
+      sumLiveObjects += currentLiveObjects;
+      printCollectionStats();
+      printHeapComposition();
+      printMutationHistograms();
+      printPointerHistograms();
+      recalculateCohortHeapPosition();
+      currentAllocations.printTable();
+      currentArrayAllocations.printTable();
+      currentGreenAllocations.printTable();
+      currentLiveSizes.printTable();
+      currentLiveArraySizes.printTable();
+      currentLiveGreenSizes.printTable();
+      currentScalarPointers.printTable();
+      currentArrayPointers.printTable();
+      currentLiveScalarPointers.printTable();
+      currentLiveArrayPointers.printTable();
+      currentIncomingPointers.printTable();
+      currentOutgoingPointers.printTable();
+      resetHistograms();
+      lastGCBirthdate = totalBytesAllocated;
+      lastGCPerfectBirthdate = totalLiveBytes;
+      firstGc = false;
+      Xml.closeTag();
+      Xml.end();
+    }
+  }
+  
+  /**
+   * Print overall run statistics
+   *
+   */
+  public static void harnessEnd() {
+    Xml.begin();
+    XmlMeasure.openTag("harness");
+    allocations.printTable();
+    arrayAllocations.printTable();
+    greenAllocations.printTable();
+    liveSizes.printTable();
+    liveArraySizes.printTable();
+    liveGreenSizes.printTable();
+    scalarPointers.printTable();
+    arrayPointers.printTable();
+    liveScalarPointers.printTable();
+    liveArrayPointers.printTable();
+    incomingPointers.printTable();
+    outgoingPointers.printTable();
+    printClassStatistics();
+    printTotals();
+    Xml.closeTag();
+    Xml.end();
+  }
+
+  public static final long now() {
+    return totalBytesAllocated;
+  }
+
+  private static final long getBirthdate(ObjectReference object) {
+    if (object.isNull()) 
+      return NULL_BIRTHDATE;
+    else
+       return ObjectModel.getBirthdate(object);
+  }
+  
+  private static final long getPerfectBirthdate(long birthdate) {
+    if (birthdate == NULL_BIRTHDATE)
+      return birthdate;
+    if (birthdate >= lastGCBirthdate) {  // no GCs done since allocated
+      return lastGCPerfectBirthdate + (birthdate - lastGCBirthdate);
+    } else {
+      int cohort = getCohortFromBirthdate(birthdate);
+      int offset = getOffsetWithinCohort(birthdate);
+      long perfect = cohortHeapPosition[cohort];
+      double scale = (double) offset / (double) cohortSize;
+      perfect += (int) (cohortLiveBytes[cohort] * scale);
+      return perfect;
+    }
+  }
+
+  private static final int getLocationBucket(long birthdate, boolean perfect) {
+    if ((((perfect) ? totalLiveBytes : totalBytesAllocated) - birthdate) < 0) {
+      Log.write(lastGCBirthdate); Log.write(" "); Log.write(birthdate); 
+      Log.write((perfect) ? " p " : " n "); Log.writeln(totalLiveBytes);
+      Assert._assert(false,"Use -X:gc:stressFactor to control GC frequency");
+    }
+    return logBaseTwo(((perfect) ? totalLiveBytes : totalBytesAllocated) - birthdate);
+  }
+  
+  private static final int getDistanceBucket(long srcBD, long tgtBD) {
+    return POINTER_DISTANCE_ZERO_BUCKET + getLogDistance(srcBD,tgtBD);
+  }
+  
+  private static final int getLogDistance(long srcBD, long tgtBD) {
+    if (srcBD == tgtBD)
+      return 0;
+    else if (tgtBD > srcBD) // young -> old
+      return logBaseTwo(tgtBD - srcBD);
+    else // old -> young
+      return -logBaseTwo(srcBD - tgtBD);
+  }
+
+  private static final int logBaseTwo(long value) {
+    if (Assert.VERIFY_ASSERTIONS) 
+      Assert._assert(value >= 0,"Attempt to calculate log2 of nonpositive number");
+    int l = 0;
+    while ((1<<l < value) && l < BITS_IN_INT)
+      l++;
+    return l;
+  }
+
+  private static final int getCohortFromBirthdate(long birthdate) {
+    if (Assert.VERIFY_ASSERTIONS) 
+      Assert._assert(birthdate != NULL_BIRTHDATE);
+    return (int)(birthdate >> logCohortSize);
+  }
+
+  private static final int getOffsetWithinCohort(long birthdate) {
+    return (int)(birthdate & (cohortSize - 1));  // We know that a cohort fits in an int.
+  }
+
+  private static final void recalculateCohortHeapPosition() {
+    int cumulativeLiveBytes = 0;
+    for (int c = 0; c < totalCohorts; c++) {
+      cohortHeapPosition[c] = cumulativeLiveBytes;
+      cumulativeLiveBytes += cohortLiveBytes[c];
+    }
+  }
+ 
+  private static final void resetHistograms() {
+    resetHistogram(mutationSrcHistogram);
+    resetHistogram(mutationTgtHistogram);
+    resetHistogram(mutationDistanceHistogram);
+    resetHistogram(perfectMutationSrcHistogram);
+    resetHistogram(perfectMutationTgtHistogram);
+    resetHistogram(perfectMutationDistanceHistogram);
+    resetHistogram(pointerSrcHistogram);
+    resetHistogram(pointerTgtHistogram);
+    resetHistogram(pointerDistanceHistogram);
+    resetHistogram(perfectPointerSrcHistogram);
+    resetHistogram(perfectPointerTgtHistogram);
+    resetHistogram(perfectPointerDistanceHistogram);
+    currentAllocations.reset();
+    currentArrayAllocations.reset();
+    currentGreenAllocations.reset();
+    currentLiveSizes.reset();
+    currentLiveArraySizes.reset();
+    currentLiveGreenSizes.reset();
+    currentScalarPointers.reset();
+    currentArrayPointers.reset();
+    currentLiveScalarPointers.reset();
+    currentLiveArrayPointers.reset();
+    currentIncomingPointers.reset();
+    currentOutgoingPointers.reset();
+  }
+
+  private static final void resetHistogram(long[] histo) {
+    for (int i = 0; i < histo.length; i++) histo[i] = 0;
+  }
+  
+  /************************************************************************************
+   * Print results
+   *
+   */
+  
+  /**
+   * Print stats that apply to 
+   */
+  private static final void printCollectionStats() {
+  }
+  
+  private static final void printHeapComposition() {
+    XmlMeasure.openTag("cohort-data",true,false);
+    Xml.attribute("liveObjects",totalLiveObjects); 
+    Xml.attribute("cohortSize",cohortSize); 
+    Xml.attribute("totalCohorts",totalCohorts); 
+    Xml.endTag(false);
+    
+    for (int c = 0; c < totalCohorts; c++) {
+      if (cohortLiveObjects[c] > 0) { // Reduce the output volume by not writing empty cohorts
+        Xml.openMinorTag("cohort");
+        Xml.attribute("id",c); 
+        Xml.attribute("o",cohortLiveObjects[c]); 
+        Xml.attribute("b",cohortLiveBytes[c]); 
+        Xml.closeMinorTag();
+      }
+    }
+    Xml.closeTag();
+  }
+
+  private static final void printMutationHistograms() {
+    XmlMeasure.openTag("mutation-data",true);
+    printLocationHistogram("mutation-src", mutationSrcHistogram,false);
+    printLocationHistogram("mutation-src", perfectMutationSrcHistogram,true);
+    printLocationHistogram("mutation-tgt", mutationTgtHistogram,false);
+    printLocationHistogram("mutation-tgt", perfectMutationTgtHistogram,true);
+    printDistanceHistogram("mutation-dist", mutationDistanceHistogram,false);
+    printDistanceHistogram("mutation-dist", perfectMutationDistanceHistogram,true);
+    Xml.closeTag();
+  }
+
+  private static final void printPointerHistograms() {
+    XmlMeasure.openTag("pointer-data",true);
+    printLocationHistogram("pointer-src", pointerSrcHistogram,false);
+    printLocationHistogram("pointer-src", perfectPointerSrcHistogram,true);
+    printLocationHistogram("pointer-tgt", pointerTgtHistogram,false);
+    printLocationHistogram("pointer-tgt", perfectPointerTgtHistogram,true);
+    printDistanceHistogram("pointer-dist", pointerDistanceHistogram,false);
+    printDistanceHistogram("pointer-dist", perfectPointerDistanceHistogram,true);
+    Xml.closeTag();
+  }
+  
+  private static final void printLocationHistogram(String tag, long[] hist,boolean perfect) {
+    XmlMeasure.openTag(tag,true,false);
+    if (perfect)
+      Xml.attribute("perfect","true");
+    Xml.endTag(false);
+    for (int b = 0; b < hist.length; b++) {
+      Xml.openMinorTag("bucket");
+      Xml.attribute("key",b); 
+      Xml.attribute("value",hist[b]);
+      Xml.closeMinorTag();
+    }
+    Xml.closeTag();
+  }
+  
+  private static final void printDistanceHistogram(String tag, long[] hist, boolean perfect) {
+    XmlMeasure.openTag(tag,true,false);
+    if (perfect)
+      Xml.attribute("perfect","true");
+    Xml.endTag(false);
+    for (int b = 0; b < hist.length; b++) {
+      Xml.openMinorTag("bucket");
+      Xml.attribute("key",b-POINTER_DISTANCE_ZERO_BUCKET); 
+      Xml.attribute("value",hist[b]);
+      Xml.closeMinorTag();
+    }
+    Xml.closeTag();
+  }
+  
+  private static final void printClassStatistics() {
+    Xml.singleValue("classes-loaded",maxType);
+    XmlMeasure.openTag("per-class-data");
+    for (int i=0; i < maxType; i++) {
+      MMType type = (MMType)types.get(i).toObject();
+      if (type == null) 
+	      Xml.comment("null type encountered");
+      else {
+      Xml.openMinorTag("class");
+      Xml.attribute("name",type.getName()); 
+      Log.writeln();
+      Xml.attribute("objects",type.getAllocCount()); 
+      Xml.attribute("bytes",type.getAllocBytes());
+      Log.writeln();
+      if (!type.isReferenceArray()) {
+        if (!type.isArray())
+          Xml.attribute("pointers",type.getReferences(null));
+        Xml.attribute("bitmap",type.getBitmap());
+     } else {
+        Xml.attribute("refarray","true");
+      }
+      Xml.closeMinorTag();
+      }
+    }
+    Xml.closeTag();
+  }
+  
+  static void timestamps() {
+    Xml.attribute("alloc-bytes",totalBytesAllocated);
+    Xml.attribute("mutations",totalMutations);
+    Xml.attribute("alloc-objects",totalObjectsAllocated);
+    Xml.attribute("collections",collections);
+  }
+  
+  /**
+   * Print once-per-run totals
+   *
+   */
+  private static void printTotals() {
+    Xml.singleValue("total-objects-allocated",totalObjectsAllocated);
+    Xml.singleValue("total-bytes-allocated",totalBytesAllocated);
+    Xml.singleValue("total-mutations",totalMutations);
+    Xml.singleValue("max-resident-bytes",maxLiveBytes);
+    Xml.singleValue("max-resident-objects",maxLiveObjects);
+    Xml.singleValue("total-resident-bytes",sumLiveBytes);
+    Xml.singleValue("total-resident-objects",sumLiveObjects);
+    Xml.singleValue("total-arrays-allocated",totalArraysAllocated);
+    Xml.singleValue("array-bytes-allocated",arrayBytesAllocated);
+    Xml.singleValue("total-green-objects-allocated",totalGreenObjectsAllocated);
+    Xml.singleValue("green-bytes-allocated",greenBytesAllocated);
+    Xml.singleValue("cohort-size",Options.cohortSize.getBytes().toInt());
+    Xml.singleValue("gc-interval",Options.stressFactor.getBytes().toInt());
+    Xml.singleValue("incoming-pointers",incomingPointerStats.getSum());   
+    Xml.singleValue("incoming-objects",incomingPointerStats.getCount());
+    Xml.singleValue("mean-incoming-pointers",incomingPointerStats.getMean());
+    Xml.singleValue("var-incoming-pointers",incomingPointerStats.getVariance());
+    Xml.singleValue("outgoing-pointers",outgoingPointerStats.getSum());
+    Xml.singleValue("outgoing-objects",outgoingPointerStats.getCount());
+    Xml.singleValue("mean-outgoing-pointers",outgoingPointerStats.getMean());
+    Xml.singleValue("var-outgoing-pointers",outgoingPointerStats.getVariance());
+    Xml.singleValue("roots",roots);
+    Xml.singleValue("mean-pointer-dist",pointerDistance.getMean());
+    Xml.singleValue("mean-mutation-dist",mutationDistance.getMean());
+    Xml.singleValue("var-pointer-dist",pointerDistance.getVariance());
+    Xml.singleValue("var-mutation-dist",mutationDistance.getVariance());
+  }
+  
+  /*****************************************************************************
+   * Managing reference counts
+   */
+  
+  private static final Word TOUCHED_BIT = Word.one().lsh(31);
+  private static final Word RC_MASK = TOUCHED_BIT.not();
+  
+  /**
+   * 
+   */
+  private static void setRefCount(ObjectReference obj, int count) {
+    ObjectModel.setRefcount(obj, TOUCHED_BIT.or(Word.fromIntZeroExtend(count)));
+  }
+  
+  private static int getRefCount(ObjectReference obj) {
+    return ObjectModel.getRefcount(obj).and(RC_MASK).toInt();
+  }
+  
+  private static boolean touched(ObjectReference obj) {
+    return ObjectModel.getRefcount(obj).and(TOUCHED_BIT).EQ(TOUCHED_BIT);
+  }
+  
+  private static void incRefCount(ObjectReference obj) {
+    setRefCount(obj, getRefCount(obj)+1);
+  }
+  
+  private static void decRefCount(ObjectReference obj) {
+    setRefCount(obj, getRefCount(obj)-1);
+  }
+  
+  private static int resetRefCount(ObjectReference obj) {
+    int count = getRefCount(obj);
+    ObjectModel.setRefcount(obj, Word.zero());
+    return count;
+  }
+
+
+}
diff -r -N -w -u -I '[$]Id:' --exclude='*.class' --exclude='.*' --exclude='*.orig' --exclude='*.rej' --exclude=CVS --exclude='#*' --exclude='*~' ./MMTk/src/org/mmtk/utility/statistics/Stats.java ./MMTk/src/org/mmtk/utility/statistics/Stats.java
--- ./MMTk/src/org/mmtk/utility/statistics/Stats.java	2006-11-26 00:19:45.000000000 +1100
+++ ./MMTk/src/org/mmtk/utility/statistics/Stats.java	2006-11-26 00:34:45.000000000 +1100
@@ -9,6 +9,7 @@
 import org.mmtk.utility.Log;
 import org.mmtk.utility.options.Options;
 import org.mmtk.utility.options.PrintPhaseStats;
+import org.mmtk.utility.options.XmlStats;
 
 import org.mmtk.vm.Assert;
 
@@ -29,7 +30,7 @@
    * Class variables
    */
 
-  public static final boolean GATHER_MARK_CONS_STATS = false;
+  public static final boolean GATHER_MARK_CONS_STATS = true;
 
   /** Maximum number of gc/mutator phases that can be counted */
   static final int MAX_PHASES = 1 << 12;
@@ -56,6 +57,7 @@
   static {
     counter = new Counter[MAX_COUNTERS];
     Options.printPhaseStats = new PrintPhaseStats();
+    Options.xmlStats = new XmlStats();
   }
 
   /**
@@ -119,6 +121,11 @@
       if (counter[c].getStart())
         counter[c].start();
     }
+    if (Options.xmlStats.getValue()) {
+      Xml.begin();
+      Xml.openTag("mmtk-stats");
+      Xml.end();
+    }
   }
 
   /**
@@ -132,10 +139,17 @@
     gatheringStats = false;
   }
 
+  public static void printStats() {
+    if (Options.xmlStats.getValue())
+      printStatsXml();
+    else
+      printStatsPlain();
+  }
+
   /**
    * Print out statistics
    */
-  public static void printStats() {
+  public static void printStatsPlain() {
     if (Options.printPhaseStats.getValue())
       printPhases();
     printTotals();
@@ -201,6 +215,130 @@
     Log.writeln();
   }
 
+  /* ****************************************************************
+   * 
+   *              Statistics output in xml format
+   * 
+   */
+
+  /**
+   * Print command-line options and statistics in XML format
+   */
+  public static void printStatsXml() {
+    Xml.begin();
+    Options.printOptionsXml();
+    if (Options.printPhaseStats.getValue())
+      printPhasesXml();
+    printTotalsXml();
+    Xml.closeAllTags(); // The global mmtk-stats tag
+    Xml.end();
+  }
+  
+  private static void openStatXml(String name) {
+    Xml.openMinorTag("stat");
+    Xml.attribute("name", name);
+  }
+
+  private static void closeStatXml() {
+    Xml.closeMinorTag();
+  }
+  
+  /* enum pattern */
+  static class Phase {
+    final String name;
+    private Phase(String name) { 
+      this.name = name; 
+    }
+    static final Phase MUTATOR = new Phase("mu");
+    static final Phase GC = new Phase("gc");
+    static final Phase COMBINED = new Phase("all");
+  }
+
+  /**
+   * Print out statistics totals in Xml format
+   */
+  public static void printTotalsXml() {
+    Xml.openTag("mmtk-stats-totals");
+    Xml.singleValue("gc",(phase/2)+1);
+    for (int c = 0; c < counters; c++) {
+     if (!counter[c].isComplex())
+      if (counter[c].mergePhases()) {
+        printTotalXml(counter[c],Phase.COMBINED);
+      } else {
+        printTotalXml(counter[c],Phase.MUTATOR);
+        printTotalXml(counter[c],Phase.GC);
+      }
+    }
+    Xml.singleValue("total-time",Plan.totalTime.getTotalMillis(),"ms");
+    Xml.closeTag();
+  }
+
+  /**
+   * Print a single total in an xml tag
+   * 
+   * @param c The counter
+   * @param phase The phase
+   */
+  private static void printTotalXml(Counter c, Phase phase) {
+    openStatXml(c.getName());
+    Xml.openAttribute("value");
+    if (phase == Phase.COMBINED) {
+      c.printTotal(); 
+    } else {
+      c.printTotal(phase == Phase.MUTATOR);
+      Xml.closeAttribute();
+      Xml.openAttribute("phase");
+      Log.write(phase.name);
+    }
+    Xml.closeAttribute();
+    closeStatXml();
+  }
+
+  /**
+   * Print a single phase counter in an xml tag
+   * 
+   * @param c The counter
+   * @param p The phase number
+   * @param phase The phase (null, "mu" or "gc")
+   */
+  private static void printPhaseStatXml(Counter c, int p, Phase phase) {
+    openStatXml(c.getName());
+    Xml.openAttribute("value");
+    if (phase == Phase.COMBINED) {
+      c.printCount(p); 
+    } else {
+      c.printCount(p);
+      Xml.closeAttribute();
+      Xml.openAttribute("phase");
+      Log.write(phase.name);
+   }
+    Xml.closeAttribute();
+    closeStatXml();
+  }
+
+  /**
+   * Print out statistics for each mutator/gc phase in Xml format
+   */
+  public static void printPhasesXml() {
+    Xml.openTag("mmtk-stats-per-gc");
+    for (int p = 0; p <= phase; p += 2) {
+      Xml.openTag("phase",false); 
+      Xml.attribute("gc",(p/2)+1);
+      Xml.closeMinorTag();
+      for (int c = 0; c < counters; c++) {
+       if (!counter[c].isComplex())
+        if (counter[c].mergePhases()) {
+          printPhaseStatXml(counter[c],p,Phase.COMBINED);
+        } else {
+          printPhaseStatXml(counter[c],p,Phase.MUTATOR);
+          printPhaseStatXml(counter[c],p,Phase.GC);
+        }
+      }
+      Xml.closeTag();
+    }
+    Xml.closeTag();
+  }
+
   /** @return The GC count (inclusive of any in-progress GC) */
   public static int gcCount() { return gcCount; }
 
diff -r -N -w -u -I '[$]Id:' --exclude='*.class' --exclude='.*' --exclude='*.orig' --exclude='*.rej' --exclude=CVS --exclude='#*' --exclude='*~' ./MMTk/src/org/mmtk/utility/statistics/Timer.java ./MMTk/src/org/mmtk/utility/statistics/Timer.java
--- ./MMTk/src/org/mmtk/utility/statistics/Timer.java	2006-11-26 00:19:45.000000000 +1100
+++ ./MMTk/src/org/mmtk/utility/statistics/Timer.java	2006-11-26 00:20:41.000000000 +1100
@@ -131,5 +131,25 @@
   final void printSecs(long value) {
     Log.write(Statistics.cyclesToSecs(value));
   }
+
+
+  /**
+   * Get a value in milliseconds
+   * 
+   * @param value The value to be printed
+   */
+  final double getMillis(long value) {
+    return Statistics.cyclesToMillis(value);
+  }
+
+  /**
+   * Get a value in milliseconds
+   * 
+   * @param value The value to be printed
+   */
+  final double getTotalMillis() {
+    return Statistics.cyclesToMillis(totalCount);
+  }
+
 }
 
diff -r -N -w -u -I '[$]Id:' --exclude='*.class' --exclude='.*' --exclude='*.orig' --exclude='*.rej' --exclude=CVS --exclude='#*' --exclude='*~' ./MMTk/src/org/mmtk/utility/statistics/Xml.java ./MMTk/src/org/mmtk/utility/statistics/Xml.java
--- ./MMTk/src/org/mmtk/utility/statistics/Xml.java	1970-01-01 10:00:00.000000000 +1000
+++ ./MMTk/src/org/mmtk/utility/statistics/Xml.java	2006-11-26 00:20:41.000000000 +1100
@@ -0,0 +1,311 @@
+/*
+ * (C) Copyright Department of Computer Science,
+ * Australian National University. 2006
+ */
+package org.mmtk.utility.statistics;
+
+import org.mmtk.utility.Log;
+import org.mmtk.vm.Assert;
+import org.vmmagic.pragma.Uninterruptible;
+import org.vmmagic.unboxed.ObjectReference;
+import org.vmmagic.unboxed.ObjectReferenceArray;
+import org.vmmagic.unboxed.Word;
+
+/**
+ * Utility class for writing statistics out in XML format.
+ * 
+ * @author Robin Garner
+ * @date $Date:$
+ * @id $Id:$
+ *
+ */
+public class Xml implements Uninterruptible {
+  
+  /*
+   * Stack of XML tags to simplify output.
+   */
+
+  /**
+   * Fixed sizxze stack - more than 64 levels of nesting would be pathological !
+   */
+  private static final int TAGSTACK = 64;
+
+  /**
+   * Top-of-stack of the tag stack
+   */
+  private static int curTag = -1;
+  
+  /**
+   * The stack of nested tags
+   */
+  private static ObjectReferenceArray tags = ObjectReferenceArray.create(TAGSTACK);
+  
+  /**
+   * Push a tag onto the tag stack
+   * 
+   * @param name
+   */
+  protected static void pushTag(String name) {
+    tags.set(++curTag,ObjectReference.fromObject(name));
+    if (Assert.VERIFY_ASSERTIONS) Assert._assert(curTag < TAGSTACK);
+  }
+
+  /**
+   * Pop a tag from the tag stack
+   * 
+   * @return the innermost tag
+   */
+  protected static String popTag() {
+    if (Assert.VERIFY_ASSERTIONS) Assert._assert(Xml.curTag >= 0);
+    String name = (String)tags.get(curTag--).toObject();
+    return name;
+  }
+
+  /**
+   * Mark the start of XML output
+   */
+  public static void begin() {
+    Log.writeln("<xml-begin/> <!-- Everything until xml-end is now valid xml -->");
+  }
+
+  /**
+   * Mark the end of XML output
+   */
+  public static void end() {
+    Log.writeln("<xml-end/> <!-- Non-xml data follows ... -->");
+  }
+
+  /**
+   * Close the innermost XML tag and pop it from the stack.
+   */
+  public static void closeTag() {
+    String name = popTag();
+    Log.write("</"); Log.write(name); Log.writeln(">");
+  }
+
+  /**
+   * Close all open XML tags and flush the tag stack
+   */
+  public static void closeAllTags() {
+    while (curTag >= 0)
+      closeTag();
+  }
+
+  /**
+   * Open an XML tag.
+   * 
+   * @param name Tag name
+   * @param endTag Should the tag be closed, or left open for 
+   *               adding additional attributes
+   */
+  static void openTag(String name, boolean endTag) {
+    pushTag(name);
+    openMinorTag(name);
+    if (endTag)
+      endTag(false);
+  }
+
+  /**
+   * Open a simple XML entity.
+   * 
+   * @param name
+   */
+  static void openTag(String name) { openTag(name,true); }
+
+  /**
+   * Output a "stat" entity, with a given name, <code>double</code>value and optionally, units.
+   * @param name
+   * @param value
+   * @param units
+   */
+  public static final void singleValue(String name, double value, String units) {
+    openMinorTag("stat");
+    attribute("name",name); 
+    attribute("value",value); 
+    if (units != null) attribute("units",units);
+    closeMinorTag();
+  }
+  
+  /**
+   * Convenience version of singleValue where units are not specified.
+   * 
+   * @param name
+   * @param value
+   */
+  public static final void singleValue(String name, double value) {
+    singleValue(name,value,null);
+  }
+
+  /**
+   * Output a "stat" entity, with a given name, <code>long</code> value and optionally, units.
+   * @param name
+   * @param value
+   * @param units
+   */
+  public static final void singleValue(String name, long value, String units) {
+    openMinorTag("stat");
+    attribute("name",name); 
+    attribute("value",value); 
+    if (units != null) attribute("units",units);
+    closeMinorTag();
+  }
+  
+  /**
+   * Convenience version of singleValue where units are not specified.
+   * 
+   * @param name
+   * @param value
+   */
+  public static final void singleValue(String name, long value) {
+    singleValue(name,value,null);
+  }
+
+  /**
+   * Add a word-valued attribute to an open XML tag.
+   * 
+   * @param name
+   * @param value
+   */
+  public static final void attribute(String name, Word value) {
+    openAttribute(name); Log.write(value); closeAttribute();
+  }
+
+  /**
+   * Add a byte[]-valued attribute to an open XML tag.
+   * 
+   * @param name
+   * @param value
+   */
+  public static final void attribute(String name, byte[] value) {
+    openAttribute(name); Log.write(value); closeAttribute();
+  }
+
+  /**
+   * Add a String-valued attribute to an open XML tag.
+   * 
+   * @param name
+   * @param value
+   */
+  public static final void attribute(String name, String value) {
+    openAttribute(name); Log.write(value); closeAttribute();
+  }
+
+  /**
+   * Add a double-valued attribute to an open XML tag.
+   * 
+   * @param name
+   * @param value
+   */
+  public static final void attribute(String name, double value) {
+    openAttribute(name); Log.write(value); closeAttribute();
+  }
+
+  /**
+   * Add a long-valued attribute to an open XML tag.
+   * 
+   * @param name
+   * @param value
+   */
+  public static final void attribute(String name, long value) {
+    openAttribute(name); Log.write(value); closeAttribute();
+  }
+
+  /**
+   * Add an int-valued attribute to an open XML tag.
+   * 
+   * @param name
+   * @param value
+   */
+  public static final void attribute(String name, int value) {
+    openAttribute(name); Log.write(value); closeAttribute();
+  }
+
+  /**
+   * Close an attribute (actually a simple close-quote)
+   */
+  public static final void closeAttribute() {
+    Log.write("\"");
+  }
+
+  /**
+   * Open an attribute (write "{name}=\")
+   * 
+   * @param name
+   */
+  public static final void openAttribute(String name) {
+    Log.write(" "); Log.write(name); Log.write("=\"");
+  }
+
+  /**
+   * Start a tag
+   */
+  public static final void startTag() {
+    Log.write("<"); 
+  }
+
+  /**
+   * End a tag, optionally closing it (if it is a simple entity)
+   * 
+   * @param close If true, close the tag with "/>" rather than ">"
+   */
+  public static final void endTag(boolean close) {
+    endTag(close,true);
+  }
+  
+  /**
+   * End a tag, optionally closing it (if it is a simple entity),
+   * and optionally printing end-of-line
+   * 
+   * @param close If true, close the tag with "/>" rather than ">"
+   * @param endLine If true end the current line.
+   */
+  public static final void endTag(boolean close, boolean endLine) {
+    if (close) Log.write("/");
+    Log.write(">"); 
+    if (endLine) Log.writeln();
+  }
+
+  /**
+   * Close a tag with a "/>"
+   */
+  public static final void closeMinorTag() {
+    endTag(true,true); 
+  }
+
+  /**
+   * Open a tag without pushing it on the tag stack - must end this
+   * with a call to closeMinorTag()
+   * 
+   * @param name
+   */
+  public static final void openMinorTag(String name) {
+    Log.write("<"); Log.write(name);
+  }
+
+  /**
+   * Open an XML comment
+   */
+  public static final void openComment() {
+	  Log.write("<!-- ");
+  }
+  
+  /**
+   * Close an XML comment
+   */
+  public static final void closeComment() {
+	  Log.write(" -->");
+  }
+  
+  /**
+   * Add a comment, bracketing it with open- and close-comment tags.
+   * 
+   * @param comment The comment.
+   */
+  public static final void comment(String comment) {
+	  openComment();
+	  Log.write(comment);
+	  closeComment();
+	  Log.writeln();
+  }
+
+}
diff -r -N -w -u -I '[$]Id:' --exclude='*.class' --exclude='.*' --exclude='*.orig' --exclude='*.rej' --exclude=CVS --exclude='#*' --exclude='*~' ./MMTk/src/org/mmtk/utility/statistics/XmlMeasure.java ./MMTk/src/org/mmtk/utility/statistics/XmlMeasure.java
--- ./MMTk/src/org/mmtk/utility/statistics/XmlMeasure.java	1970-01-01 10:00:00.000000000 +1000
+++ ./MMTk/src/org/mmtk/utility/statistics/XmlMeasure.java	2006-11-26 00:34:45.000000000 +1100
@@ -0,0 +1,30 @@
+/**
+ * Copyright (c) 2006 Australian National University
+ */
+package org.mmtk.utility.statistics;
+
+import org.vmmagic.pragma.*;
+
+/**
+ * Extensions to Xml specifically for output from the Measurement collector.
+ * 
+ * @author Robin Garner
+ * @date $Date:$
+ * @id $Id:$
+ *
+ */
+public class XmlMeasure extends Xml implements Uninterruptible {
+  static void openTag(String name, boolean timestamp, boolean endTag) {
+    pushTag(name);
+    openMinorTag(name);
+    if (timestamp)
+      Measurement.timestamps(); 
+    if (endTag)
+      endTag(false);
+  }
+
+  static void openTag(String name, boolean timestamp) {
+    openTag(name,timestamp,true);
+  }
+
+}
