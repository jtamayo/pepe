diff -r -N -w -u -I '[$]Id:' --exclude='*.class' --exclude='.*' --exclude='*.orig' --exclude='*.rej' --exclude=CVS --exclude='#*' --exclude='*~' ./MMTk/ext/vm/JikesRVM/com/ibm/JikesRVM/mm/mmtk/ObjectModel.java ./MMTk/ext/vm/JikesRVM/com/ibm/JikesRVM/mm/mmtk/ObjectModel.java
--- ./MMTk/ext/vm/JikesRVM/com/ibm/JikesRVM/mm/mmtk/ObjectModel.java	2006-11-27 10:20:06.000000000 +1100
+++ ./MMTk/ext/vm/JikesRVM/com/ibm/JikesRVM/mm/mmtk/ObjectModel.java	2006-11-23 18:12:54.000000000 +1100
@@ -13,6 +13,7 @@
 
 import org.mmtk.utility.scan.MMType;
 import org.mmtk.utility.Constants;
+import org.mmtk.utility.statistics.Measurement;
 import org.mmtk.utility.alloc.Allocator;
 
 import com.ibm.JikesRVM.VM;
@@ -41,7 +42,7 @@
  * @version $Revision: 1.6 $
  * @date $Date: 2006/06/19 06:08:15 $
  */
-public final class ObjectModel extends org.mmtk.vm.ObjectModel implements Constants, VM_Constants, Uninterruptible {
+public final class ObjectModel extends org.mmtk.vm.ObjectModel implements VM_Constants, Uninterruptible {
 
   protected final Offset getArrayBaseOffset() { return VM_JavaHeaderConstants.ARRAY_BASE_OFFSET; }
 
@@ -424,5 +425,58 @@
     if (VM.VerifyAssertions) VM._assert(vmType.getMMType() != null);
     return (MMType) vmType.getMMType();
   }
+  
+  /*
+   * Extra header fields for the measurement collector
+   */
+  private final Offset BIRTHDAY_HIGH = GC_HEADER_OFFSET();
+  private final Offset BIRTHDAY_LOW = BIRTHDAY_HIGH.plus(BYTES_IN_INT);
+  private final Offset REFCOUNT = BIRTHDAY_LOW.plus(BYTES_IN_INT);
+  private final Offset PTRCOUNT = REFCOUNT.plus(BYTES_IN_INT);
+  
+  /**
+   * set the birthdate of an object - Measurement plan specific, lives in 
+   * an extra word in the header
+   */
+  public void setBirthdate(ObjectReference object, long birthday) {
+    if (VM.VerifyAssertions)
+      VM._assert(Measurement.MEASURE_DETAIL,"Measurement header does not exist");
+    //-#if RVM_FOR_64_ADDR
+    object.toAddress().store(Word.fromLong(birthday) ,BIRTHDAY_HIGH);
+    //-#else
+    Word high = Word.fromInt((int)((birthday&0xFFFFFFFF00000000L)>>BITS_IN_WORD));
+    Word low  = Word.fromInt((int)( birthday&0x00000000FFFFFFFFL));
+    object.toAddress().store(high ,BIRTHDAY_HIGH);
+    object.toAddress().store(low  ,BIRTHDAY_LOW);
+    //-#endif
+  }
+  
+  /**
+   * get the birthdate of an object - Measurement plan specific, lives in 
+   * an extra word in the header
+   */
+  public long getBirthdate(ObjectReference object) {
+    //-#if RVM_FOR_64_ADDR
+    return object.toAddress().loadWord(BIRTHDAY_HIGH).toLong();
+    //-#else
+    long high = (long)(object.toAddress().loadWord(BIRTHDAY_HIGH).toInt())<<BITS_IN_WORD;
+    long low = object.toAddress().loadWord(BIRTHDAY_LOW).toInt()&0xFFFFFFFFL;
+    return high | low;
+    //-#endif
+  }
+
+  public void setRefcount(ObjectReference object, Word count) {
+    int c = count.toInt();
+    object.toAddress().store(count ,REFCOUNT);
+  }
+  public Word getRefcount(ObjectReference object) {
+    return Word.fromIntZeroExtend(object.toAddress().loadInt(REFCOUNT));
+  }
+  public void setPtrcount(ObjectReference object, int count) {
+    object.toAddress().store(count ,PTRCOUNT);
+  }
+  public int getPtrcount(ObjectReference object) {
+    return object.toAddress().loadInt(PTRCOUNT);
+  }
 }
 
diff -r -N -w -u -I '[$]Id:' --exclude='*.class' --exclude='.*' --exclude='*.orig' --exclude='*.rej' --exclude=CVS --exclude='#*' --exclude='*~' ./MMTk/src/org/mmtk/plan/generational/GenNurseryTraceLocal.java ./MMTk/src/org/mmtk/plan/generational/GenNurseryTraceLocal.java
--- ./MMTk/src/org/mmtk/plan/generational/GenNurseryTraceLocal.java	2006-11-27 10:20:07.000000000 +1100
+++ ./MMTk/src/org/mmtk/plan/generational/GenNurseryTraceLocal.java	2006-11-23 17:24:52.000000000 +1100
@@ -103,7 +103,7 @@
     logMessage(5, "processing remset");
     while (!remset.isEmpty()) {
       Address loc = remset.pop();
-      traceObjectLocation(loc, false);
+      traceObjectLocation(null, loc, false);
     }
     logMessage(5, "processing array remset");
     arrayRemset.flushLocal();
@@ -111,7 +111,7 @@
       Address start = arrayRemset.pop1();
       Address guard = arrayRemset.pop2();
       while (start.LT(guard)) {
-        traceObjectLocation(start, false);
+        traceObjectLocation(null, start, false);
         start = start.plus(BYTES_IN_ADDRESS);
       }
     }
diff -r -N -w -u -I '[$]Id:' --exclude='*.class' --exclude='.*' --exclude='*.orig' --exclude='*.rej' --exclude=CVS --exclude='#*' --exclude='*~' ./MMTk/src/org/mmtk/plan/measurement/MeasureCollector.java ./MMTk/src/org/mmtk/plan/measurement/MeasureCollector.java
--- ./MMTk/src/org/mmtk/plan/measurement/MeasureCollector.java	1970-01-01 10:00:00.000000000 +1000
+++ ./MMTk/src/org/mmtk/plan/measurement/MeasureCollector.java	2006-11-27 12:01:14.000000000 +1100
@@ -0,0 +1,27 @@
+package org.mmtk.plan.measurement;
+
+import org.mmtk.plan.semispace.SSCollector;
+import org.mmtk.vm.VM;
+
+import org.vmmagic.pragma.*;
+
+public class MeasureCollector extends SSCollector implements Uninterruptible {
+
+  /****************************************************************************
+   * Instance fields
+   */
+
+  public MeasureCollector() {
+    super(new MeasureTraceLocal(global().ssTrace));
+  }
+
+  /****************************************************************************
+   * 
+   * Miscellaneous
+   */
+
+  /** @return The active global plan as an <code>SS</code> instance. */
+  private static final Measure global() throws InlinePragma {
+    return (Measure) VM.activePlan.global();
+  }
+}
diff -r -N -w -u -I '[$]Id:' --exclude='*.class' --exclude='.*' --exclude='*.orig' --exclude='*.rej' --exclude=CVS --exclude='#*' --exclude='*~' ./MMTk/src/org/mmtk/plan/measurement/MeasureConstraints.java ./MMTk/src/org/mmtk/plan/measurement/MeasureConstraints.java
--- ./MMTk/src/org/mmtk/plan/measurement/MeasureConstraints.java	1970-01-01 10:00:00.000000000 +1000
+++ ./MMTk/src/org/mmtk/plan/measurement/MeasureConstraints.java	2006-11-23 17:24:52.000000000 +1100
@@ -0,0 +1,17 @@
+package org.mmtk.plan.measurement;
+
+import org.mmtk.plan.semispace.SSConstraints;
+import org.mmtk.utility.statistics.Measurement;
+
+import org.vmmagic.pragma.*;
+
+public class MeasureConstraints extends SSConstraints implements Uninterruptible {
+
+  public int gcHeaderWords() {
+    return super.gcHeaderWords() + Measurement.MEASUREMENT_HEADER_WORDS;
+  }
+  
+  public boolean needsWriteBarrier() {
+    return super.needsWriteBarrier() || Measurement.MEASURE_DETAIL;
+  }
+}
diff -r -N -w -u -I '[$]Id:' --exclude='*.class' --exclude='.*' --exclude='*.orig' --exclude='*.rej' --exclude=CVS --exclude='#*' --exclude='*~' ./MMTk/src/org/mmtk/plan/measurement/Measure.java ./MMTk/src/org/mmtk/plan/measurement/Measure.java
--- ./MMTk/src/org/mmtk/plan/measurement/Measure.java	1970-01-01 10:00:00.000000000 +1000
+++ ./MMTk/src/org/mmtk/plan/measurement/Measure.java	2006-11-23 17:24:52.000000000 +1100
@@ -0,0 +1,77 @@
+package org.mmtk.plan.measurement;
+
+import org.mmtk.plan.semispace.SS;
+import org.mmtk.utility.options.*;
+import org.mmtk.utility.statistics.Measurement;
+
+import org.vmmagic.pragma.*;
+
+public class Measure extends SS implements Uninterruptible {
+
+  static long lastStressTime = 0;
+  
+  static {
+    Options.cohortSize = new CohortSize();
+  }
+  
+  public Measure() {
+    super();
+  }
+
+  /** 
+   * Start the measurement subsystem at boot time, after options 
+   * become available
+   */
+  public void postBoot() throws InterruptiblePragma {
+    super.postBoot();
+    if (Measurement.MEASURE_DETAIL) 
+      Measurement.boot();
+  }
+  
+  /** Add some measurement calls to the benchmark harness */
+  public void harnessBegin() throws InterruptiblePragma {
+    super.harnessBegin();
+    Measurement.start();
+  }
+  
+  /** Add some measurement calls to the benchmark harness */
+  public void harnessEnd() throws InterruptiblePragma {
+    System.gc();
+    Measurement.stop();
+    Measurement.harnessEnd();
+    super.harnessEnd();
+  }
+  
+  /**
+   * Redefine stress test conditions so that it only applies during
+   * the measurement phase.
+   * 
+   * @return True is a stress test GC is required
+   */
+  public boolean stressTestGCRequired() throws InlinePragma {
+    long now = Measurement.now();
+    if (insideHarness &&
+        ((now ^ lastStressTime) > Options.cohortSize.getBytes().toInt())) {
+      lastStressTime = now;
+      return true;
+    } else
+      return false;
+  }
+  
+  /**
+   * Put hooks into the GC process
+   */
+  public void collectionPhase(int phase) throws InlinePragma {
+    if (phase == PREPARE) {
+      Measurement.gcStart();
+      super.collectionPhase(phase);
+      return;
+    }
+    if (phase == RELEASE) {
+      super.collectionPhase(phase);
+      Measurement.gcEnd();
+      return;
+    }
+    super.collectionPhase(phase);
+  }
+}
diff -r -N -w -u -I '[$]Id:' --exclude='*.class' --exclude='.*' --exclude='*.orig' --exclude='*.rej' --exclude=CVS --exclude='#*' --exclude='*~' ./MMTk/src/org/mmtk/plan/measurement/MeasureMutator.java ./MMTk/src/org/mmtk/plan/measurement/MeasureMutator.java
--- ./MMTk/src/org/mmtk/plan/measurement/MeasureMutator.java	1970-01-01 10:00:00.000000000 +1000
+++ ./MMTk/src/org/mmtk/plan/measurement/MeasureMutator.java	2006-11-27 10:50:03.000000000 +1100
@@ -0,0 +1,91 @@
+package org.mmtk.plan.measurement;
+
+import org.mmtk.plan.semispace.SSMutator;
+import org.mmtk.utility.statistics.*;
+import org.mmtk.vm.VM;
+
+import org.vmmagic.unboxed.*;
+import org.vmmagic.pragma.*;
+
+public class MeasureMutator extends SSMutator implements Uninterruptible {
+
+  /****************************************************************************
+   *
+   * Allocation
+   */
+ 
+  
+  
+  /**
+   * Allocate space (for an object)
+   *
+   * @param bytes The size of the space to be allocated (in bytes)
+   * @param align The requested alignment.
+   * @param offset The alignment offset.
+   * @param allocator The allocator number to be used for this allocation
+   * @return The address of the first byte of the allocated region
+   */
+  public void postAlloc(ObjectReference object, ObjectReference typeRef,
+          int bytes, int allocator)
+    throws InlinePragma {
+    if (Measurement.MEASURE_DETAIL) {
+      Measurement.objectCreation(object, bytes);
+    }
+    super.postAlloc(object,typeRef, bytes, allocator);
+  }
+  
+  /**
+   * A new reference is about to be created.  Take appropriate write
+   * barrier actions.<p> 
+   *
+   * In this case, we remember the address of the source of the
+   * pointer if the new reference points into the nursery from
+   * non-nursery space.
+   *
+   * @param src The object into which the new reference will be stored
+   * @param slot The address into which the new reference will be
+   * stored.
+   * @param tgt The target of the new reference
+   * @param metaDataA A field used by the VM to create a correct store.
+   * @param metaDataB A field used by the VM to create a correct store.
+   * @param mode The mode of the store (eg putfield, putstatic etc)
+   */
+  public void writeBarrier(ObjectReference src, Address slot,
+          ObjectReference tgt, Offset metaDataA,
+          int metaDataB, int mode)
+  throws InlinePragma {
+    Measurement.pointerMutation(src, slot, tgt);
+    VM.barriers.performWriteInBarrier(src, slot, tgt, metaDataA, metaDataB, mode);
+  }
+  
+  /**
+   * A number of references are about to be copied from object
+   * <code>src</code> to object <code>dst</code> (as in an array
+   * copy).  Thus, <code>dst</code> is the mutated object.  Take
+   * appropriate write barrier actions.<p>
+   *
+   * In this case, we remember the mutated source address range and
+   * will scan that address range at GC time.
+   *
+   * @param src The source of the values to copied
+   * @param srcOffset The offset of the first source address, in
+   * bytes, relative to <code>src</code> (in principle, this could be
+   * negative).
+   * @param dst The mutated object, i.e. the destination of the copy.
+   * @param dstOffset The offset of the first destination address, in
+   * bytes relative to <code>tgt</code> (in principle, this could be
+   * negative).
+   * @param bytes The size of the region being copied, in bytes.
+   * @return True if the update was performed by the barrier, false if
+   * left to the caller (always false in this case).
+   */
+  public boolean writeBarrier(ObjectReference src, Offset srcOffset,
+          ObjectReference dst, Offset dstOffset,
+          int bytes)  
+  throws InlinePragma {
+    Measurement.pointerMutations(src.toAddress().plus(srcOffset).toObjectReference(), dst, bytes);
+    return false;
+  }
+  
+  
+}
diff -r -N -w -u -I '[$]Id:' --exclude='*.class' --exclude='.*' --exclude='*.orig' --exclude='*.rej' --exclude=CVS --exclude='#*' --exclude='*~' ./MMTk/src/org/mmtk/plan/measurement/MeasureTraceLocal.java ./MMTk/src/org/mmtk/plan/measurement/MeasureTraceLocal.java
--- ./MMTk/src/org/mmtk/plan/measurement/MeasureTraceLocal.java	1970-01-01 10:00:00.000000000 +1000
+++ ./MMTk/src/org/mmtk/plan/measurement/MeasureTraceLocal.java	2006-11-27 12:05:43.000000000 +1100
@@ -0,0 +1,43 @@
+package org.mmtk.plan.measurement;
+
+import org.mmtk.plan.Trace;
+import org.mmtk.plan.semispace.SSTraceLocal;
+import org.mmtk.utility.Log;
+import org.mmtk.utility.statistics.Measurement;
+import org.mmtk.vm.VM;
+import org.vmmagic.pragma.InlinePragma;
+import org.vmmagic.pragma.Uninterruptible;
+import org.vmmagic.unboxed.Address;
+import org.vmmagic.unboxed.ObjectReference;
+
+public class MeasureTraceLocal extends SSTraceLocal implements Uninterruptible {
+  private static final boolean DEBUG = false;
+  
+  public MeasureTraceLocal(Trace trace) {
+    super(trace);
+  }
+
+  //@Override
+  public void enqueue(ObjectReference object) throws InlinePragma {
+    if (Measurement.MEASURE_DETAIL)
+      Measurement.liveObject(object, VM.objectModel.getSizeWhenCopied(object));
+
+    super.enqueue(object);
+  }
+
+  /* (non-Javadoc)
+   * @see org.mmtk.plan.TraceLocal#traceObjectLocation(org.vmmagic.unboxed.ObjectReference, org.vmmagic.unboxed.Address, boolean)
+   */
+  //@Override
+  public void traceObjectLocation(ObjectReference srcObj, Address objLoc, boolean root) throws InlinePragma {
+    super.traceObjectLocation(srcObj, objLoc, root);
+    if (DEBUG) { Log.write("REF["); Log.write(srcObj); }
+    if (Measurement.MEASURE_DETAIL && !srcObj.isNull()) {
+      if (DEBUG) { Log.write(" -> "); Log.write(objLoc.loadObjectReference()); }
+      Measurement.livePointer(srcObj, objLoc.loadObjectReference());
+    }
+    if (DEBUG) { Log.writeln("]"); }
+  }
+  
+  
+}
diff -r -N -w -u -I '[$]Id:' --exclude='*.class' --exclude='.*' --exclude='*.orig' --exclude='*.rej' --exclude=CVS --exclude='#*' --exclude='*~' ./MMTk/src/org/mmtk/plan/MutatorContext.java ./MMTk/src/org/mmtk/plan/MutatorContext.java
--- ./MMTk/src/org/mmtk/plan/MutatorContext.java	2006-11-27 10:20:07.000000000 +1100
+++ ./MMTk/src/org/mmtk/plan/MutatorContext.java	2006-11-23 17:24:52.000000000 +1100
@@ -118,7 +118,7 @@
   public abstract void collectionPhase(int phaseId, boolean primary);
 
   /** Current dynamic allocation scope */
-  private int currentScope = Plan.DEFAULT_SCOPE;
+  public int currentScope = Plan.DEFAULT_SCOPE;
 
   /****************************************************************************
    * Scoped allocation policy
diff -r -N -w -u -I '[$]Id:' --exclude='*.class' --exclude='.*' --exclude='*.orig' --exclude='*.rej' --exclude=CVS --exclude='#*' --exclude='*~' ./MMTk/src/org/mmtk/plan/Plan.java ./MMTk/src/org/mmtk/plan/Plan.java
--- ./MMTk/src/org/mmtk/plan/Plan.java	2006-11-27 12:44:06.000000000 +1100
+++ ./MMTk/src/org/mmtk/plan/Plan.java	2006-11-23 17:46:31.000000000 +1100
@@ -71,7 +71,7 @@
   public static final int GC_PROPER = 2;
 
   /* Polling */
-  public static final int DEFAULT_POLL_FREQUENCY = (128 << 10) >> LOG_BYTES_IN_PAGE;
+  public static final int DEFAULT_POLL_FREQUENCY = (4 << 10) >> LOG_BYTES_IN_PAGE;
   public static final int META_DATA_POLL_FREQUENCY = DEFAULT_POLL_FREQUENCY;
 
   /* Space Size Constants. */
@@ -166,6 +166,7 @@
     Options.eagerMmapSpaces = new EagerMmapSpaces();
     Options.sanityCheck = new SanityCheck();
     Options.debugAddress = new DebugAddress();
+    Options.harnessWholeRun = new HarnessWholeRun();
   }
 
   /****************************************************************************
@@ -202,6 +203,8 @@
     initialized = true;
     exceptionReserve = (int) (getTotalPages() *
                               (1 - Collection.OUT_OF_MEMORY_THRESHOLD));
+    if (Options.harnessWholeRun.getValue())
+      harnessBegin();
   }
 
   /**
@@ -210,6 +213,8 @@
    * @param value The exit value
    */
   public void notifyExit(int value) {
+    if (Options.harnessWholeRun.getValue())
+      harnessEnd();
     if (Options.verbose.getValue() == 1) {
       Log.write("[End ");
       totalTime.printTotalSecs();
@@ -307,7 +312,7 @@
     return false;
   }
 
-  private long lastStressPages = 0;
+  protected long lastStressPages = 0;
 
   /**
    * @return The current sanity checker.
@@ -319,7 +324,7 @@
   /**
    * @return True is a stress test GC is required
    */
-  public final boolean stressTestGCRequired()
+  public boolean stressTestGCRequired()
     throws InlinePragma {
     long pages = Space.cumulativeCommittedPages();
     if (initialized &&
@@ -491,7 +496,7 @@
    * instrumentation, etc.  By default we do a full heap GC,
    * and then start stats collection.
    */
-  public static void harnessBegin() throws InterruptiblePragma {
+  public void harnessBegin() throws InterruptiblePragma {
     // Save old values.
     boolean oldFullHeap = Options.fullHeapSystemGC.getValue();
     boolean oldIgnore = Options.ignoreSystemGC.getValue();
@@ -519,7 +524,7 @@
    * instrumentation, etc.  By default we stop all statistics objects
    * and print their values.
    */
-  public static void harnessEnd() throws InterruptiblePragma {
+  public void harnessEnd() throws InterruptiblePragma {
     Stats.stopAll();
     Stats.printStats();
     insideHarness = false;
diff -r -N -w -u -I '[$]Id:' --exclude='*.class' --exclude='.*' --exclude='*.orig' --exclude='*.rej' --exclude=CVS --exclude='#*' --exclude='*~' ./MMTk/src/org/mmtk/plan/refcount/cd/TrialDeletionCollectStep.java ./MMTk/src/org/mmtk/plan/refcount/cd/TrialDeletionCollectStep.java
--- ./MMTk/src/org/mmtk/plan/refcount/cd/TrialDeletionCollectStep.java	2006-11-27 10:20:07.000000000 +1100
+++ ./MMTk/src/org/mmtk/plan/refcount/cd/TrialDeletionCollectStep.java	2006-11-23 17:48:27.000000000 +1100
@@ -27,11 +27,10 @@
 
   /**
    * Trace a reference during GC.
-   * 
    * @param objLoc The location containing the object reference to be
    * traced.
    */
-  public void traceObjectLocation(Address objLoc) {
+  public void traceObjectLocation(ObjectReference source, Address objLoc) {
     ObjectReference object = objLoc.loadObjectReference();
     ((TrialDeletionCollector)CDCollector.current()).enumerateCollect(object);
   }
diff -r -N -w -u -I '[$]Id:' --exclude='*.class' --exclude='.*' --exclude='*.orig' --exclude='*.rej' --exclude=CVS --exclude='#*' --exclude='*~' ./MMTk/src/org/mmtk/plan/refcount/cd/TrialDeletionGreyStep.java ./MMTk/src/org/mmtk/plan/refcount/cd/TrialDeletionGreyStep.java
--- ./MMTk/src/org/mmtk/plan/refcount/cd/TrialDeletionGreyStep.java	2006-11-27 10:20:07.000000000 +1100
+++ ./MMTk/src/org/mmtk/plan/refcount/cd/TrialDeletionGreyStep.java	2006-11-23 17:48:27.000000000 +1100
@@ -27,11 +27,10 @@
 
   /**
    * Trace a reference during GC.
-   * 
    * @param objLoc The location containing the object reference to be
    * traced.
    */
-  public void traceObjectLocation(Address objLoc) {
+  public void traceObjectLocation(ObjectReference source, Address objLoc) {
     ObjectReference object = objLoc.loadObjectReference();
     ((TrialDeletionCollector)CDCollector.current()).enumerateGrey(object);
   }
diff -r -N -w -u -I '[$]Id:' --exclude='*.class' --exclude='.*' --exclude='*.orig' --exclude='*.rej' --exclude=CVS --exclude='#*' --exclude='*~' ./MMTk/src/org/mmtk/plan/refcount/cd/TrialDeletionScanBlackStep.java ./MMTk/src/org/mmtk/plan/refcount/cd/TrialDeletionScanBlackStep.java
--- ./MMTk/src/org/mmtk/plan/refcount/cd/TrialDeletionScanBlackStep.java	2006-11-27 10:20:07.000000000 +1100
+++ ./MMTk/src/org/mmtk/plan/refcount/cd/TrialDeletionScanBlackStep.java	2006-11-23 17:48:27.000000000 +1100
@@ -27,11 +27,10 @@
 
   /**
    * Trace a reference during GC.
-   * 
    * @param objLoc The location containing the object reference to be
    * traced.
    */
-  public void traceObjectLocation(Address objLoc) {
+  public void traceObjectLocation(ObjectReference source, Address objLoc) {
     ObjectReference object = objLoc.loadObjectReference();
     ((TrialDeletionCollector)CDCollector.current()).enumerateScanBlack(object);
   }
diff -r -N -w -u -I '[$]Id:' --exclude='*.class' --exclude='.*' --exclude='*.orig' --exclude='*.rej' --exclude=CVS --exclude='#*' --exclude='*~' ./MMTk/src/org/mmtk/plan/refcount/cd/TrialDeletionScanStep.java ./MMTk/src/org/mmtk/plan/refcount/cd/TrialDeletionScanStep.java
--- ./MMTk/src/org/mmtk/plan/refcount/cd/TrialDeletionScanStep.java	2006-11-27 10:20:07.000000000 +1100
+++ ./MMTk/src/org/mmtk/plan/refcount/cd/TrialDeletionScanStep.java	2006-11-23 17:48:28.000000000 +1100
@@ -27,11 +27,10 @@
 
   /**
    * Trace a reference during GC.
-   * 
    * @param objLoc The location containing the object reference to be
    * traced.
    */
-  public void traceObjectLocation(Address objLoc) {
+  public void traceObjectLocation(ObjectReference source, Address objLoc) {
     ObjectReference object = objLoc.loadObjectReference();
     ((TrialDeletionCollector)CDCollector.current()).enumerateScan(object);
   }
diff -r -N -w -u -I '[$]Id:' --exclude='*.class' --exclude='.*' --exclude='*.orig' --exclude='*.rej' --exclude=CVS --exclude='#*' --exclude='*~' ./MMTk/src/org/mmtk/plan/refcount/fullheap/RCModifiedProcessor.java ./MMTk/src/org/mmtk/plan/refcount/fullheap/RCModifiedProcessor.java
--- ./MMTk/src/org/mmtk/plan/refcount/fullheap/RCModifiedProcessor.java	2006-11-27 10:20:07.000000000 +1100
+++ ./MMTk/src/org/mmtk/plan/refcount/fullheap/RCModifiedProcessor.java	2006-11-23 17:48:27.000000000 +1100
@@ -34,11 +34,10 @@
 
   /**
    * Trace a reference during GC.
-   * 
    * @param objLoc The location containing the object reference to be
    * traced.
    */
-  public void traceObjectLocation(Address objLoc) {
+  public void traceObjectLocation(ObjectReference source, Address objLoc) {
     ObjectReference object = objLoc.loadObjectReference();
     if (RC.isRCObject(object)) {
       RCHeader.incRC(object);
diff -r -N -w -u -I '[$]Id:' --exclude='*.class' --exclude='.*' --exclude='*.orig' --exclude='*.rej' --exclude=CVS --exclude='#*' --exclude='*~' ./MMTk/src/org/mmtk/plan/refcount/generational/GenRCModifiedProcessor.java ./MMTk/src/org/mmtk/plan/refcount/generational/GenRCModifiedProcessor.java
--- ./MMTk/src/org/mmtk/plan/refcount/generational/GenRCModifiedProcessor.java	2006-11-27 10:20:07.000000000 +1100
+++ ./MMTk/src/org/mmtk/plan/refcount/generational/GenRCModifiedProcessor.java	2006-11-23 17:34:13.000000000 +1100
@@ -45,7 +45,7 @@
    * @param objLoc The location containing the object reference to be
    * traced.
    */
-  public void traceObjectLocation(Address objLoc) throws InlinePragma {
+  public void traceObjectLocation(ObjectReference src, Address objLoc) throws InlinePragma {
     ObjectReference object = objLoc.loadObjectReference();
     if (!object.isNull()) {
       if (Space.isInSpace(GenRC.NS, object)) {
diff -r -N -w -u -I '[$]Id:' --exclude='*.class' --exclude='.*' --exclude='*.orig' --exclude='*.rej' --exclude=CVS --exclude='#*' --exclude='*~' ./MMTk/src/org/mmtk/plan/semispace/SSCollector.java ./MMTk/src/org/mmtk/plan/semispace/SSCollector.java
--- ./MMTk/src/org/mmtk/plan/semispace/SSCollector.java	2006-11-27 10:20:07.000000000 +1100
+++ ./MMTk/src/org/mmtk/plan/semispace/SSCollector.java	2006-11-23 17:30:39.000000000 +1100
@@ -51,7 +51,7 @@
    * Instance fields
    */
 
-  protected final SSTraceLocal trace;
+  protected SSTraceLocal trace;
   protected final CopyLocal ss;
 
   /****************************************************************************
@@ -98,7 +98,6 @@
       VM.assertions._assert(bytes <= Plan.LOS_SIZE_THRESHOLD);
       VM.assertions._assert(allocator == SS.ALLOC_SS);
     }
-
     return ss.alloc(bytes, align, offset, true);
   }
 
diff -r -N -w -u -I '[$]Id:' --exclude='*.class' --exclude='.*' --exclude='*.orig' --exclude='*.rej' --exclude=CVS --exclude='#*' --exclude='*~' ./MMTk/src/org/mmtk/plan/TraceLocal.java ./MMTk/src/org/mmtk/plan/TraceLocal.java
--- ./MMTk/src/org/mmtk/plan/TraceLocal.java	2006-11-27 10:20:07.000000000 +1100
+++ ./MMTk/src/org/mmtk/plan/TraceLocal.java	2006-11-27 12:01:24.000000000 +1100
@@ -80,12 +80,12 @@
    * Trace a reference during GC.  This involves determining which
    * collection policy applies and calling the appropriate
    * <code>trace</code> method.
-   *
+   * @param srcObj TODO
    * @param objLoc The location containing the object reference to be
    * traced.  The object reference is <i>NOT</i> an interior pointer.
    * @param root True if <code>objLoc</code> is within a root.
    */
-  public final void traceObjectLocation(Address objLoc, boolean root)
+  public void traceObjectLocation(ObjectReference srcObj, Address objLoc, boolean root)
       throws InlinePragma {
     ObjectReference object = objLoc.loadObjectReference();
     ObjectReference newObject = traceObject(object, root);
@@ -97,13 +97,14 @@
    * collection policy applies and calling the appropriate
    * <code>trace</code> method.  This reference is presumed <i>not</i>
    * to be from a root.
-   *
+   * @param object TODO
    * @param objLoc The location containing the object reference to be
    * traced.  The object reference is <i>NOT</i> an interior pointer.
    */
-  public final void traceObjectLocation(Address objLoc)
+  //@Override
+  public final void traceObjectLocation(ObjectReference srcObj, Address objLoc)
     throws InlinePragma {
-    traceObjectLocation(objLoc, false);
+    traceObjectLocation(srcObj, objLoc, false);
   }
 
   /**
@@ -162,7 +163,7 @@
    * 
    * @param object The object to be enqueued
    */
-  public final void enqueue(ObjectReference object) throws InlinePragma {
+  public void enqueue(ObjectReference object) throws InlinePragma {
     values.push(object);
   }
 
@@ -445,7 +446,7 @@
     logMessage(5, "processing root locations");
     while (!rootLocations.isEmpty()) {
       Address loc = rootLocations.pop();
-      traceObjectLocation(loc, true);
+      traceObjectLocation(null, loc, true);
     }
     logMessage(5, "processing interior root locations");
     while (!interiorRootLocations.isEmpty()) {
diff -r -N -w -u -I '[$]Id:' --exclude='*.class' --exclude='.*' --exclude='*.orig' --exclude='*.rej' --exclude=CVS --exclude='#*' --exclude='*~' ./MMTk/src/org/mmtk/plan/TraceStep.java ./MMTk/src/org/mmtk/plan/TraceStep.java
--- ./MMTk/src/org/mmtk/plan/TraceStep.java	2006-11-27 10:20:07.000000000 +1100
+++ ./MMTk/src/org/mmtk/plan/TraceStep.java	2006-11-27 11:49:16.000000000 +1100
@@ -30,9 +30,9 @@
 
   /**
    * Trace a reference during GC.
-   * 
+   * @param source The source object
    * @param objLoc The location containing the object reference to be
    * traced.
    */
-  public abstract void traceObjectLocation(Address objLoc);
+  public abstract void traceObjectLocation(ObjectReference source, Address objLoc);
 }
diff -r -N -w -u -I '[$]Id:' --exclude='*.class' --exclude='.*' --exclude='*.orig' --exclude='*.rej' --exclude=CVS --exclude='#*' --exclude='*~' ./MMTk/src/org/mmtk/utility/deque/ObjectReferenceBuffer.java ./MMTk/src/org/mmtk/utility/deque/ObjectReferenceBuffer.java
--- ./MMTk/src/org/mmtk/utility/deque/ObjectReferenceBuffer.java	2006-11-27 10:20:07.000000000 +1100
+++ ./MMTk/src/org/mmtk/utility/deque/ObjectReferenceBuffer.java	2006-11-23 17:48:27.000000000 +1100
@@ -53,10 +53,9 @@
   
   /**
    * Transitive step.
-   * 
    * @param loc The location containing the object reference to process.
    */
-  public final void traceObjectLocation(Address loc) throws InlinePragma {
+  public final void traceObjectLocation(ObjectReference source, Address loc) throws InlinePragma {
     ObjectReference object = loc.loadObjectReference();
     process(object);
   }
diff -r -N -w -u -I '[$]Id:' --exclude='*.class' --exclude='.*' --exclude='*.orig' --exclude='*.rej' --exclude=CVS --exclude='#*' --exclude='*~' ./MMTk/src/org/mmtk/utility/Log.java ./MMTk/src/org/mmtk/utility/Log.java
--- ./MMTk/src/org/mmtk/utility/Log.java	2006-11-27 10:20:07.000000000 +1100
+++ ./MMTk/src/org/mmtk/utility/Log.java	2006-11-23 17:44:04.000000000 +1100
@@ -214,18 +214,18 @@
       write("NaN");
       return;
     }
-    if (d > Integer.MAX_VALUE) {
+    if (d > Long.MAX_VALUE) {
       write("TooBig");
       return;
     }
-    if (d < -Integer.MAX_VALUE) {
+    if (d < -Long.MAX_VALUE) {
       write("TooSmall");
       return;
     }
 
     boolean negative = (d < 0.0);
     d = negative ? (-d) : d;       // Take absolute value
-    int ones = (int) d;
+    long ones = (long) d;
     int multiplier = 1;
     while (postDecimalDigits-- > 0)
       multiplier *= 10;
diff -r -N -w -u -I '[$]Id:' --exclude='*.class' --exclude='.*' --exclude='*.orig' --exclude='*.rej' --exclude=CVS --exclude='#*' --exclude='*~' ./MMTk/src/org/mmtk/utility/options/BooleanOption.java ./MMTk/src/org/mmtk/utility/options/BooleanOption.java
--- ./MMTk/src/org/mmtk/utility/options/BooleanOption.java	2006-11-27 10:20:07.000000000 +1100
+++ ./MMTk/src/org/mmtk/utility/options/BooleanOption.java	2006-11-23 17:24:52.000000000 +1100
@@ -77,4 +77,8 @@
     }
     validate();
   }
+  
+  /**
+   * Print the current value on standard output.
+   */
 }
diff -r -N -w -u -I '[$]Id:' --exclude='*.class' --exclude='.*' --exclude='*.orig' --exclude='*.rej' --exclude=CVS --exclude='#*' --exclude='*~' ./MMTk/src/org/mmtk/utility/options/CohortSize.java ./MMTk/src/org/mmtk/utility/options/CohortSize.java
--- ./MMTk/src/org/mmtk/utility/options/CohortSize.java	1970-01-01 10:00:00.000000000 +1000
+++ ./MMTk/src/org/mmtk/utility/options/CohortSize.java	2006-11-23 17:24:52.000000000 +1100
@@ -0,0 +1,41 @@
+/*
+ * (C) Copyright Department of Computer Science,
+ * Australian National University. 2004
+ */
+package org.mmtk.utility.options;
+
+import org.mmtk.utility.Constants;
+import org.mmtk.utility.statistics.Measurement;
+
+/**
+ * The granularity of the trace being produced.
+ *
+ * $Id: 02-measurement.patch,v 1.2 2006/07/19 04:12:18 steveb Exp $
+ *
+ * @author Daniel Frampton
+ * @version $Revision: 1.2 $
+ * @date $Date: 2006/07/19 04:12:18 $
+ */
+public class CohortSize extends PagesOption
+  implements org.mmtk.utility.Constants {
+  /**
+   * Create the option.
+   */
+  public CohortSize() {
+    super("Cohort Size",
+          "Size in bytes of a heap cohort (must be 2^n for some n)",
+          1 << (Constants.BITS_IN_INT - Constants.LOG_BYTES_IN_PAGE));
+  }
+
+  /**
+   * Trace rate must be positive.
+   */
+  protected void validate() {
+    int bytes = getBytes().toInt();
+    failIf(bytes < Measurement.MIN_COHORT_SIZE, "Cohort size less than minimum");
+    int logCohortSize;
+    for (logCohortSize = 0; bytes > (1<<logCohortSize); logCohortSize++)
+      ;
+    failIf(bytes != 1<<logCohortSize,"Cohort size must be a power of 2");
+  }
+}
diff -r -N -w -u -I '[$]Id:' --exclude='*.class' --exclude='.*' --exclude='*.orig' --exclude='*.rej' --exclude=CVS --exclude='#*' --exclude='*~' ./MMTk/src/org/mmtk/utility/options/HarnessWholeRun.java ./MMTk/src/org/mmtk/utility/options/HarnessWholeRun.java
--- ./MMTk/src/org/mmtk/utility/options/HarnessWholeRun.java	1970-01-01 10:00:00.000000000 +1000
+++ ./MMTk/src/org/mmtk/utility/options/HarnessWholeRun.java	2006-11-23 17:46:31.000000000 +1100
@@ -0,0 +1,25 @@
+/*
+ * (C) Copyright Department of Computer Science,
+ * Australian National University. 2004
+ */
+package org.mmtk.utility.options;
+
+/**
+ * Should a major GC be performed when a system GC is triggered?
+ * 
+ * $Id: X0-harnesshack.patch,v 1.1 2006/07/19 04:12:18 steveb Exp $
+ * 
+ * @author Daniel Frampton
+ * @version $Revision: 1.1 $
+ * @date $Date: 2006/07/19 04:12:18 $
+ */
+public class HarnessWholeRun extends BooleanOption {
+  /**
+   * Create the option.
+   */
+  public HarnessWholeRun() {
+    super("Harness Whole Run",
+          "Should we implicitly use the measurement harness for the whole run?",
+          false);
+  }
+}
diff -r -N -w -u -I '[$]Id:' --exclude='*.class' --exclude='.*' --exclude='*.orig' --exclude='*.rej' --exclude=CVS --exclude='#*' --exclude='*~' ./MMTk/src/org/mmtk/utility/options/Options.java ./MMTk/src/org/mmtk/utility/options/Options.java
--- ./MMTk/src/org/mmtk/utility/options/Options.java	2006-11-27 12:32:07.000000000 +1100
+++ ./MMTk/src/org/mmtk/utility/options/Options.java	2006-11-27 12:30:55.000000000 +1100
@@ -27,6 +27,7 @@
 
   /* Other options */
   public static BoundedNursery boundedNursery;
+  public static CohortSize cohortSize;
   public static CycleFilterThreshold cycleFilterThreshold;
   public static CycleMetaDataLimit cycleMetaDataLimit;
   public static CycleTriggerThreshold cycleTriggerThreshold;
@@ -42,6 +43,7 @@
   public static GCspyWait gcspyWait;
   public static GCTimeCap gcTimeCap;
   public static GenCycleDetection genCycleDetection;
+  public static HarnessWholeRun harnessWholeRun;
   public static IgnoreSystemGC ignoreSystemGC;
   public static MarkSweepMarkBits markSweepMarkBits;
   public static MetaDataLimit metaDataLimit;
diff -r -N -w -u -I '[$]Id:' --exclude='*.class' --exclude='.*' --exclude='*.orig' --exclude='*.rej' --exclude=CVS --exclude='#*' --exclude='*~' ./MMTk/src/org/mmtk/utility/scan/MMType.java ./MMTk/src/org/mmtk/utility/scan/MMType.java
--- ./MMTk/src/org/mmtk/utility/scan/MMType.java	2006-11-27 10:20:07.000000000 +1100
+++ ./MMTk/src/org/mmtk/utility/scan/MMType.java	2006-11-27 00:07:55.000000000 +1100
@@ -12,6 +12,7 @@
 
 import org.mmtk.utility.Constants;
 import org.mmtk.vm.VM;
+//import org.mmtk.utility.statistics.Measurement;
 
 import org.vmmagic.unboxed.*;
 import org.vmmagic.pragma.*;
@@ -27,20 +28,30 @@
 public final class MMType implements Constants, Uninterruptible {
   // AJG: Maybe should make this immutable. See Item 13 of Effective Java.
   private final boolean isReferenceArray;
+  private final boolean isArray;
   private final boolean isDelegated;
   private final boolean isAcyclic;
+  private Offset arrayOffset = Offset.zero();
   private final int[] offsets;
   private final int allocator;
+  private boolean hasBitmap = false;
+  private Word bitmap = Word.zero();
+  private final byte[] name;
+
 
   // per-type statistics
   private int allocCount;
-  private int allocBytes;
+  private long allocBytes;
   private int copyCount;
   private int copyBytes;
   private int scanCount;
   private int scanBytes;
 
-  private static final boolean PROFILING_STATISTICS = false;
+  //Link to the measurement plan
+  private int typeId = -1;
+  
+  private static final boolean PROFILING_STATISTICS = true;
+  private static final int MAX_BITMAP_SIZE = 32;
 
   /****************************************************************************
    * 
@@ -58,14 +69,38 @@
    * @param offsets An array of integer offsets for the fields of this
    * type (if any).
    */
-  public MMType(boolean isDelegated, boolean isReferenceArray,
-      boolean isAcyclic, int allocator, int[] offsets)
+  public MMType(boolean isDelegated, boolean isReferenceArray, boolean isArray,
+                boolean isAcyclic, int allocator, int [] offsets, byte[] name)
       throws InterruptiblePragma {
     this.isDelegated = isDelegated;
     this.isReferenceArray = isReferenceArray;
+    this.isArray = isArray;
     this.isAcyclic = isAcyclic;
     this.allocator = allocator;
     this.offsets = offsets;
+    this.name = name;
+  }
+
+  public void installBitmap() {
+    // Build a bitmap if the object is compact enough and is not a reference array
+    if( offsets.length == 0 ) {
+      bitmap = Word.zero();
+      hasBitmap = !isReferenceArray;
+    } else if( bit_for_offset(offsets[offsets.length-1]) < MAX_BITMAP_SIZE ) {
+      Word map = Word.zero();
+      for( int i=0; i < offsets.length; i++ ) {
+        map = map.or(Word.one().lsh(bit_for_offset(offsets[i])));
+      }
+      bitmap = map;
+      hasBitmap = true;
+    } else {
+      bitmap = Word.zero();
+      hasBitmap = false;
+    }
+  }
+
+  private int bit_for_offset(int offset) {
+    return (offset >> LOG_BYTES_IN_ADDRESS) + 1;
   }
 
   /****************************************************************************
@@ -85,7 +120,7 @@
   public Address getSlot(ObjectReference object, int reference) throws InlinePragma {
     Address addr = object.toAddress();
     if (isReferenceArray)
-      return addr.plus(VM.ARRAY_BASE_OFFSET).plus(reference << LOG_BYTES_IN_ADDRESS);
+      return addr.plus(arrayOffset).plus(reference << LOG_BYTES_IN_ADDRESS);
     else
       return addr.plus(offsets[reference]);
   }
@@ -115,7 +150,7 @@
    * 
    * @param size The number of bytes allocated
    */
-  void profileAlloc(int size) throws InlinePragma {
+  public void profileAlloc(int size) throws InlinePragma {
     if (PROFILING_STATISTICS) {
       allocCount++;
       allocBytes += size;
@@ -157,10 +192,29 @@
   /** @return True if this type is an array of references */
   public boolean isReferenceArray() { return isReferenceArray; }
 
+  /** @return True if this type is an array of references */
+  public boolean isArray() { return isArray; }
+
   /** @return True if this type is known to be inherently acyclic */
   public boolean isAcyclic() { return isAcyclic; }
 
   /** @return The allocator to be used by default for this type */
   public int getAllocator() { return allocator; }
 
+  /** Accessor method for hasBitmap */
+  public boolean hasBitmap() throws InlinePragma { return hasBitmap; }
+
+  /** Accessor method for the bitmap */
+  public Word getBitmap() throws InlinePragma { return bitmap; }
+
+  /** Accessor method for typeId */
+  public int getTypeId() { return typeId; }
+  public void setTypeId(int typeId) { this.typeId = typeId; }
+  
+  /** Accessor method for the type name */
+  public byte[] getName() throws InlinePragma { return name; }
+
+  /** Accessor methods for allocation stats */
+  public int getAllocCount() { return allocCount; }
+  public long getAllocBytes() { return allocBytes; }
 }
diff -r -N -w -u -I '[$]Id:' --exclude='*.class' --exclude='.*' --exclude='*.orig' --exclude='*.rej' --exclude=CVS --exclude='#*' --exclude='*~' ./MMTk/src/org/mmtk/utility/scan/Scan.java ./MMTk/src/org/mmtk/utility/scan/Scan.java
--- ./MMTk/src/org/mmtk/utility/scan/Scan.java	2006-11-27 10:20:07.000000000 +1100
+++ ./MMTk/src/org/mmtk/utility/scan/Scan.java	2006-11-23 17:50:29.000000000 +1100
@@ -13,6 +13,7 @@
 
 import org.mmtk.plan.TraceLocal;
 import org.mmtk.plan.TraceStep;
+import org.mmtk.utility.statistics.*;
 
 import org.mmtk.vm.VM;
 
@@ -42,7 +43,7 @@
       int references = type.getReferences(object);
       for (int i = 0; i < references; i++) {
         Address slot = type.getSlot(object, i);
-        trace.traceObjectLocation(slot);
+        trace.traceObjectLocation(object,slot);
       }
     } else
       VM.scanning.scanObject(trace, object);
diff -r -N -w -u -I '[$]Id:' --exclude='*.class' --exclude='.*' --exclude='*.orig' --exclude='*.rej' --exclude=CVS --exclude='#*' --exclude='*~' ./MMTk/src/org/mmtk/utility/statistics/Accumulator.java ./MMTk/src/org/mmtk/utility/statistics/Accumulator.java
--- ./MMTk/src/org/mmtk/utility/statistics/Accumulator.java	1970-01-01 10:00:00.000000000 +1000
+++ ./MMTk/src/org/mmtk/utility/statistics/Accumulator.java	2006-11-23 17:24:52.000000000 +1100
@@ -0,0 +1,28 @@
+package org.mmtk.utility.statistics;
+
+import org.vmmagic.pragma.*;
+
+public class Accumulator implements Uninterruptible {
+
+  private long count = 0;
+  private double sum = 0;
+  private double sum_sqd = 0;
+  
+  public void add(double point) {
+    count++;
+    sum += point;
+    sum_sqd += point * point;
+  }
+  
+  public void reset() {
+    count = 0;
+    sum = sum_sqd = 0;
+  }
+  
+  public long getCount() { return count; }
+  public double getSum() { return sum; }
+  public double getMean() { return sum/count; }
+  public double getVariance() {
+    return sum_sqd/count - getMean() * getMean();
+  }
+}
diff -r -N -w -u -I '[$]Id:' --exclude='*.class' --exclude='.*' --exclude='*.orig' --exclude='*.rej' --exclude=CVS --exclude='#*' --exclude='*~' ./MMTk/src/org/mmtk/utility/statistics/Histogram.java ./MMTk/src/org/mmtk/utility/statistics/Histogram.java
--- ./MMTk/src/org/mmtk/utility/statistics/Histogram.java	1970-01-01 10:00:00.000000000 +1000
+++ ./MMTk/src/org/mmtk/utility/statistics/Histogram.java	2006-11-27 11:12:57.000000000 +1100
@@ -0,0 +1,171 @@
+/**
+ * (C) Copyright Department of Computer Science,
+ * Australian National University. 2005
+ */
+package org.mmtk.utility.statistics;
+
+import org.mmtk.vm.VM;
+
+import org.vmmagic.pragma.*;
+
+/**
+ * @author Robin Garner
+ *
+ */
+public class Histogram extends Counter implements Uninterruptible {
+
+  private final int[] buckets;
+  private final long[] counts;
+  private final long[] sums;
+  private boolean running = false;
+  
+  /**
+   * @param name Name of the counter
+   * @param buckets The thresholds for the histogram buckets
+   */
+  public Histogram(String name, int[] buckets) {
+    super(name);
+    this.complex = true;
+    this.buckets = buckets;
+    this.counts = new long[buckets.length+1];
+    this.sums = new long[buckets.length+1];
+    VM.assertions._assert(false,"Histograms do not support mutator/GC phases yet");
+  }
+
+  /**
+   * @param name
+   * @param start
+   */
+  public Histogram(String name, int[] buckets, boolean start) {
+    super(name, start);
+    this.complex = true;
+    this.buckets = buckets;
+    this.counts = new long[buckets.length+1];
+    this.sums = new long[buckets.length+1];
+    VM.assertions._assert(false,"Histograms do not support mutator/GC phases yet");
+  }
+
+  /**
+   * @param name
+   * @param start
+   * @param mergephases
+   */
+  public Histogram(String name, int[] buckets, boolean start, boolean mergephases) {
+    super(name, start, mergephases);
+    this.complex = true;
+    this.buckets = buckets;
+    this.counts = new long[buckets.length+1];
+    this.sums = new long[buckets.length+1];
+  }
+
+  void reset() {
+    for (int i=0; i < counts.length; i++) {
+      counts[i] = 0;
+      sums[i] = 0;
+    }
+  }
+  
+  /**
+   * Add a value to the histogram.
+   * 
+   * @param value The value to add.
+   */
+  public void add(int value) {
+    if (running) {
+      for (int i=0; i <= buckets.length; i++) {
+        if (i == buckets.length || buckets[i] >= value) {
+          counts[i]++;
+          sums[i] += value;
+          break;
+        }
+      }
+    }
+  }
+
+  /**
+   * @see org.mmtk.utility.statistics.Counter#start()
+   */
+  void start() {
+    running = true;
+  }
+
+  /**
+   * @see org.mmtk.utility.statistics.Counter#stop()
+   */
+  void stop() {
+    running = false;
+  }
+
+  /* (non-Javadoc)
+   * @see org.mmtk.utility.statistics.Counter#phaseChange(int)
+   */
+  void phaseChange(int oldPhase) {
+    // We don't support phases yet
+  }
+
+  /* (non-Javadoc)
+   * @see org.mmtk.utility.statistics.Counter#printCount(int)
+   */
+  void printCount(int phase) {
+    // TODO Auto-generated method stub
+
+  }
+
+  /* (non-Javadoc)
+   * @see org.mmtk.utility.statistics.Counter#printTotal()
+   */
+  void printTotal() {
+    // TODO Auto-generated method stub
+
+  }
+
+  /* (non-Javadoc)
+   * @see org.mmtk.utility.statistics.Counter#printTotal(boolean)
+   */
+  void printTotal(boolean mutator) {
+    // TODO Auto-generated method stub
+
+  }
+
+  /* (non-Javadoc)
+   * @see org.mmtk.utility.statistics.Counter#printMin(boolean)
+   */
+  void printMin(boolean mutator) {
+    // TODO Auto-generated method stub
+
+  }
+
+  /* (non-Javadoc)
+   * @see org.mmtk.utility.statistics.Counter#printMax(boolean)
+   */
+  void printMax(boolean mutator) {
+    // TODO Auto-generated method stub
+
+  }
+
+  /**
+   * Print the table of accumulated values
+   * 
+   * Don't print buckets with zero values.
+   */
+  void printTable() {
+    XmlMeasure.openTag(getName(),true);
+    int last = 0;
+    for (int i=0; i < buckets.length; i++) {
+      Xml.openMinorTag("bucket");
+      Xml.attribute("low", last); 
+      Xml.attribute("high",buckets[i]);
+      Xml.attribute("count",counts[i]);
+      Xml.attribute("sum",sums[i]);
+      Xml.closeMinorTag();
+      last = buckets[i];
+    }
+    Xml.openMinorTag("bucket");
+    Xml.attribute("low", last); 
+    Xml.attribute("high",Integer.MAX_VALUE);
+    Xml.attribute("count",counts[buckets.length]);
+    Xml.attribute("sum",sums[buckets.length]);
+    Xml.closeMinorTag();
+    Xml.closeTag();
+  }
+}
diff -r -N -w -u -I '[$]Id:' --exclude='*.class' --exclude='.*' --exclude='*.orig' --exclude='*.rej' --exclude=CVS --exclude='#*' --exclude='*~' ./MMTk/src/org/mmtk/utility/statistics/LogHistogram.java ./MMTk/src/org/mmtk/utility/statistics/LogHistogram.java
--- ./MMTk/src/org/mmtk/utility/statistics/LogHistogram.java	1970-01-01 10:00:00.000000000 +1000
+++ ./MMTk/src/org/mmtk/utility/statistics/LogHistogram.java	2006-11-23 17:24:52.000000000 +1100
@@ -0,0 +1,49 @@
+package org.mmtk.utility.statistics;
+
+public class LogHistogram extends Histogram {
+
+  private static int[] genBuckets(int logMax) {
+    int[] result = new int[2*(logMax+1)+2];
+    int lowBound = Integer.MIN_VALUE;
+    int highBound = -(1<<logMax);
+    int i=0;
+    while (highBound < 0) {
+      result[i++] = lowBound;
+      lowBound = highBound;
+      highBound /= 2;
+    }
+    result[i++] = -1;
+    lowBound = 0;
+    highBound = 1;
+    while (lowBound <= (1<<logMax)) {
+      result[i++] = lowBound;
+      lowBound = highBound;
+      highBound <<= 1;
+    }
+    return result;
+  }
+  
+  public static void main(String[] args) {
+    int[] x = genBuckets(Integer.parseInt(args[0]));
+    for (int i=0; i < x.length; i++) {
+      System.out.println(i+" "+x[i]);
+    }
+  }
+  
+  public LogHistogram(String name, int logMax) {
+    super(name, genBuckets(logMax));
+    // TODO Auto-generated constructor stub
+  }
+
+  public LogHistogram(String name, int[] buckets, boolean start) {
+    super(name, buckets, start);
+    // TODO Auto-generated constructor stub
+  }
+
+  public LogHistogram(String name, int[] buckets, boolean start,
+      boolean mergephases) {
+    super(name, buckets, start, mergephases);
+    // TODO Auto-generated constructor stub
+  }
+
+}
diff -r -N -w -u -I '[$]Id:' --exclude='*.class' --exclude='.*' --exclude='*.orig' --exclude='*.rej' --exclude=CVS --exclude='#*' --exclude='*~' ./MMTk/src/org/mmtk/utility/statistics/Measurement.java ./MMTk/src/org/mmtk/utility/statistics/Measurement.java
--- ./MMTk/src/org/mmtk/utility/statistics/Measurement.java	1970-01-01 10:00:00.000000000 +1000
+++ ./MMTk/src/org/mmtk/utility/statistics/Measurement.java	2006-11-27 10:45:10.000000000 +1100
@@ -0,0 +1,868 @@
+/*
+ * (C) Copyright Department of Computer Science,
+ * Australian National University. 2003
+ */
+package org.mmtk.utility.statistics;
+
+import org.mmtk.plan.Plan;
+import org.mmtk.policy.Space;
+import org.mmtk.utility.Log;
+import org.mmtk.utility.scan.MMType;
+import org.mmtk.utility.options.Options;
+import org.mmtk.utility.Constants;
+
+import org.mmtk.vm.VM;
+
+import org.vmmagic.pragma.*;
+import org.vmmagic.unboxed.*;
+
+/*
+ * @author Fahad Gilani
+ * @author <a href="http://cs.anu.edu.au/~Steve.Blackburn">Steve Blackburn</a>
+ * @author <a href="http://cs.anu.edu.au/~Robin.Garner">Robin Garner</a>
+ *
+ * @version $Revision: 1.2 $
+ * @date $Date: 2006/07/19 04:12:18 $
+ */
+public class Measurement implements Constants, Uninterruptible {
+  
+  /* Do reference counting */
+  public static final boolean MEASURE_REFS = true;
+
+  private static final int[] ALLOC_BUCKETS_FINE = new int[] { 
+    0,      4,      8,     12,     
+    16,     20,     24,     32,     36,     40,     44,     48,     52,     56,     60,     64,  // Step by 4
+    80,     96,    112,    128,    144,    160,    176,    192,    208,    224,    240,    256,  // Step by 16
+    330,    396,    460,    512,    576,    640,    704,    768,    832,    896,    960,   1024,  // Step by 64
+    1280,   1536,   1792,   2048,   2304,   2560,   2816,   3072,   3328,   3584,   3840,   4096,  // Step by 256
+    5120,   6144,   7168,   8192,   9216,  10240,  11264,  12288,  13312,  14336,  15360,  16384,  // Step by 1024
+    20480,  24576,  28672,  32768,  36864,  40960,  45056,  49152,  53248,  57344,  61440,  65536,  // Step by 4096
+    81920,  98304, 114688, 131072, 147456, 163840, 180224, 196608, 212992, 229376, 245760, 262144,  // Step by 16K
+    327680, 393216, 458752, 524288, 589824, 655360, 720896, 786432, 851968, 917504, 983040,1048576,  // Step by 64K
+    1310720,1572864,1835008,2097152,2359296,2621440,2883584,3145728,3407872,3670016,3932160,4194304   // Step by 256K
+  };
+  private static final int[] ALLOC_BUCKETS_COARSE = new int[] { 
+    0,      
+    4,      8,     12,     16,     20,     24,     32,             // Step by 4
+    36,     40,     44,     48,     52,     56,     60,
+    64,    128,    192,    256,    330,    396,    460,             // Step by 64
+    512,    576,   640,    704,    768,    832,    896,    960,   
+    1024,  2048,   3072,   4096,   5120,   6144,   7168,            // Step by 1K
+    8192,   9216, 10240,  11264,  12288,  13312,  14336,  15360,  
+    16384, 32768,  49152, 65536,  98304, 114688, 131072,            // Step by 16K
+    147456, 163840, 180224, 196608, 212992, 229376, 245760, 
+    262144,  524288, 786432, 1048576                                // Step by 256K
+  };
+  public static final int[] ALLOC_BUCKETS = ALLOC_BUCKETS_COARSE;
+  
+  private static final int verbose = 0;
+  public static final boolean MEASURE_DETAIL = true;
+  public static final int MEASUREMENT_HEADER_WORDS = 
+    (MEASURE_DETAIL ? 2 : 0) + (MEASURE_REFS ? 2 : 0);
+  public static final int MEASUREMENT_HEADER_BYTES = 
+    MEASUREMENT_HEADER_WORDS * BYTES_IN_WORD;
+
+  public static final int LOG_MIN_COHORT_SIZE = 10;                  // 4KB
+  public static final int MIN_COHORT_SIZE = 1<<LOG_MIN_COHORT_SIZE;  // 64KB
+  private static final long MAX_ALLOCATION = (1L << 36) - 1;           // 32GB XXX
+  private static final int MAX_COHORTS = 1<<18;
+  private static final int POINTER_LOC_BUCKETS = LOG_BYTES_IN_ADDRESS_SPACE+1;
+  private static final int POINTER_DISTANCE_ZERO_BUCKET = POINTER_LOC_BUCKETS;
+  private static final int POINTER_DIST_BUCKETS = (2*POINTER_LOC_BUCKETS) + 1;
+  
+  private static final int MAX_TYPES = 1<<16;                        // Track this many classes
+  
+  private static final long NULL_BIRTHDATE = 0;
+  
+  private static final int[] POINTER_BUCKETS_FINE = new int[] {
+       0,    1,    2,    3,    4,     
+       5,    6,    7,    8,    9,   10,   11,   12,   13,   14,   15,   16, 
+      20,   24,   28,   32,   36,   40,   44,   48,   52,   56,   60,   64,
+      80,   96,  112,  128,  144,  160,  176,  192,  208,  224,  240,  256,
+     330,  396,  460,  512,  576,  640,  704,  768,  832,  896,  960, 1024,  // Step by 64
+    1280, 1536, 1792, 2048, 2304, 2560, 2816, 3072, 3328, 3584, 3840, 4096,  // Step by 256
+  };
+  private static final int[] POINTER_BUCKETS_COARSE = new int[] {
+    0,    1,    2,    3,    4,     
+    5,    6,    7,    8,    10,   12,   14,   16, 
+   24,   32,   40,   48,   56,   64,
+   96,  128,  160,  192,  224,  256,
+  396,  512,  640,  768,  896, 1024,  // Step by 128
+ 1536, 2048, 2560, 3072, 3584, 4096,  // Step by 512
+};
+  private static final int[] POINTER_BUCKETS = POINTER_BUCKETS_COARSE;
+
+  /**
+   * Turn measurement on or off - for example to measure 
+   * the nth run of a benchmark
+   */
+  public static boolean measuring = false;
+  
+  /**
+   * Set to false after the first GC while measuring
+   */
+  private static boolean firstGc = true;
+  
+  private static int collections = 0;
+  
+  // allocation cohorts
+  private static int[] cohortLiveObjects;
+  private static int[] cohortLiveBytes;
+  private static long[] cohortHeapPosition;
+  private static int totalCohorts;
+  private static int totalLiveBytes;
+  private static int totalLiveObjects;
+  private static int maxLiveObjects = 0;
+  private static int maxLiveBytes = 0;
+  private static int currentLiveBytes;                   // Bytes live counted during GC
+  private static int currentLiveObjects;                 // Objects live counted during GC
+  private static long sumLiveBytes = 0;                  // Cumulative count of live bytes
+  private static long sumLiveObjects = 0;                // Cumulative count of live objects
+  private static int logCohortSize;
+  private static long cohortSize;
+  private static long totalBytesAllocated = 0;
+  private static long totalObjectsAllocated = 0;
+  private static long arrayBytesAllocated = 0;
+  private static long totalArraysAllocated = 0;
+  private static long greenBytesAllocated = 0;
+  private static long totalGreenObjectsAllocated = 0;
+  private static long lastGCBirthdate = 0;
+  private static long lastGCPerfectBirthdate = 0;
+  
+  /* Allow average pointer stats */
+  private static Accumulator outgoingPointerStats = new Accumulator();
+  private static Accumulator incomingPointerStats = new Accumulator();
+  private static long roots = 0;
+
+  // pointer mutations
+  private static long totalMutations = 0;
+  private static long totalNonNullMutations = 0;
+  private static long[] mutationSrcHistogram;
+  private static long[] mutationTgtHistogram;
+  private static long[] mutationDistanceHistogram;
+  private static long[] perfectMutationSrcHistogram;
+  private static long[] perfectMutationTgtHistogram;
+  private static long[] perfectMutationDistanceHistogram;
+
+  // pointers (as at GC time)
+  private static long totalPointers = 0;
+  private static long[] pointerSrcHistogram;
+  private static long[] pointerTgtHistogram;
+  private static long[] pointerDistanceHistogram;
+  private static long[] perfectPointerSrcHistogram;
+  private static long[] perfectPointerTgtHistogram;
+  private static long[] perfectPointerDistanceHistogram;
+
+  /** Allocation statistics */
+  private static Histogram allocations = new Histogram("allocations",ALLOC_BUCKETS,true,true);
+  private static Histogram arrayAllocations = new Histogram("arrayAllocations",ALLOC_BUCKETS,true,true);
+  private static Histogram greenAllocations = new Histogram("greenAllocations",ALLOC_BUCKETS,true,true);
+  private static Histogram liveSizes = new Histogram("liveSizes",ALLOC_BUCKETS,true,true);
+  private static Histogram liveArraySizes = new Histogram("liveArraySizes",ALLOC_BUCKETS,true,true);
+  private static Histogram liveGreenSizes = new Histogram("liveGreenSizes",ALLOC_BUCKETS,true,true);
+  private static Histogram currentAllocations = new Histogram("currentAllocations",ALLOC_BUCKETS,true,true);
+  private static Histogram currentLiveSizes = new Histogram("currentLiveSizes",ALLOC_BUCKETS,true,true);
+  private static Histogram currentArrayAllocations = new Histogram("currentArrayAllocations",ALLOC_BUCKETS,true,true);
+  private static Histogram currentLiveArraySizes = new Histogram("currentLiveArraySizes",ALLOC_BUCKETS,true,true);
+  private static Histogram currentGreenAllocations = new Histogram("currentGreenAllocations",ALLOC_BUCKETS,true,true);
+  private static Histogram currentLiveGreenSizes = new Histogram("currentLiveGreenSizes",ALLOC_BUCKETS,true,true);
+  
+  /** Pointer statistics */
+  private static Histogram scalarPointers = new Histogram("scalarPointers",POINTER_BUCKETS,true,true);
+  private static Histogram arrayPointers = new Histogram("arrayPointers",POINTER_BUCKETS,true,true);
+  private static Histogram liveScalarPointers = new Histogram("liveScalarPointers",POINTER_BUCKETS,true,true);
+  private static Histogram liveArrayPointers = new Histogram("liveArrayPointers",POINTER_BUCKETS,true,true);
+  private static Histogram incomingPointers = new Histogram("incomingPointers",POINTER_BUCKETS,true,true);
+  private static Histogram outgoingPointers = new Histogram("outgoingPointers",POINTER_BUCKETS,true,true);
+  
+  private static Histogram currentScalarPointers = new Histogram("currentScalarPointers",POINTER_BUCKETS,true,true);
+  private static Histogram currentArrayPointers = new Histogram("currentArrayPointers",POINTER_BUCKETS,true,true);
+  private static Histogram currentLiveScalarPointers = new Histogram("currentLiveScalarPointers",POINTER_BUCKETS,true,true);
+  private static Histogram currentLiveArrayPointers = new Histogram("currentLiveArrayPointers",POINTER_BUCKETS,true,true);
+  private static Histogram currentIncomingPointers = new Histogram("currentIncomingPointers",POINTER_BUCKETS,true,true);
+  private static Histogram currentOutgoingPointers = new Histogram("currentOutgoingPointers",POINTER_BUCKETS,true,true);
+  
+  /** Per-type statistics */
+  private static ObjectReferenceArray types;
+  private static int maxType = 0;
+  
+  private static Accumulator mutationDistance = new Accumulator(); 
+  private static Accumulator pointerDistance = new Accumulator(); 
+
+  static {
+    cohortLiveObjects = new int[MAX_COHORTS];
+    cohortLiveBytes = new int[MAX_COHORTS];
+    cohortHeapPosition = new long[MAX_COHORTS];
+
+    mutationSrcHistogram = new long[POINTER_LOC_BUCKETS];
+    mutationTgtHistogram = new long[POINTER_LOC_BUCKETS];
+    mutationDistanceHistogram = new long[POINTER_DIST_BUCKETS];
+    perfectMutationSrcHistogram = new long[POINTER_LOC_BUCKETS];
+    perfectMutationTgtHistogram = new long[POINTER_LOC_BUCKETS];
+    perfectMutationDistanceHistogram = new long[POINTER_DIST_BUCKETS];
+
+    pointerSrcHistogram = new long[POINTER_LOC_BUCKETS];
+    pointerTgtHistogram = new long[POINTER_LOC_BUCKETS];
+    pointerDistanceHistogram = new long[POINTER_DIST_BUCKETS];
+    perfectPointerSrcHistogram = new long[POINTER_LOC_BUCKETS];
+    perfectPointerTgtHistogram = new long[POINTER_LOC_BUCKETS];
+    perfectPointerDistanceHistogram = new long[POINTER_DIST_BUCKETS];
+    
+    types = ObjectReferenceArray.create(MAX_TYPES);
+  }
+
+  /**
+   * The system is up and running.  Perform basic initialization
+   */
+  public static final void boot() {
+    // Calculate the log of the cohort size
+    cohortSize = Options.cohortSize.getBytes().toInt();
+    for (logCohortSize = LOG_MIN_COHORT_SIZE; cohortSize > (1<<logCohortSize); logCohortSize++)
+      ;
+  }
+
+  public static final void start() {
+    measuring = true;
+    if (verbose >= 1) Log.writeln("Measurement enabled");
+  }
+
+  public static final void stop() {
+    measuring = false;
+    if (verbose >= 1) Log.writeln("Measurement disabled");
+  }
+
+
+  /**
+   * A reference array copy has occured, perform appropriate
+   * bookkeeping. 
+   * 
+   * @param src The first word to be copied
+   * @param tgt The mutated object
+   * @param bytes The number of bytes to be copied
+   */
+  public static final void pointerMutations(ObjectReference src, ObjectReference tgt,
+					    int bytes) {
+    Address cursor = src.toAddress();
+    Address slot = tgt.toAddress();
+    while (bytes > 0) {
+      pointerMutation(tgt, slot, cursor.loadObjectReference());
+      cursor = cursor.plus(BYTES_IN_ADDRESS);
+      slot = slot.plus(BYTES_IN_ADDRESS);
+      bytes -= BYTES_IN_ADDRESS;
+    }
+  }
+
+
+  /**
+   * A pointer has been mutated, perform appropriate bookkeeping.
+   * This should be called each time a pointer is mutated.
+   * 
+   * @param src The object containing the mutated pointer
+   * @param tgt The object pointed to
+   */
+  public static final void pointerMutation(ObjectReference src, Address slot, ObjectReference tgt)
+  throws NoInlinePragma {
+    if (measuring && VM.activePlan.mutator().currentScope == Plan.DEFAULT_SCOPE) {
+      if (VM.VERIFY_ASSERTIONS) VM.assertions._assert(!src.isNull());
+      if (verbose >= 5) Log.writeln("Pointer mutation");
+      long srcBD = getBirthdate(src);
+      if (srcBD != NULL_BIRTHDATE) {
+        totalMutations++;
+        if (!tgt.isNull()) {
+          totalNonNullMutations++;
+          long tgtBD = getBirthdate(tgt);
+          long srcPerfectBD = getPerfectBirthdate(srcBD);
+          long tgtPerfectBD = getPerfectBirthdate(tgtBD);
+          mutationSrcHistogram[getLocationBucket(srcBD, false)]++;
+          mutationTgtHistogram[getLocationBucket(tgtBD, false)]++;
+          mutationDistanceHistogram[getDistanceBucket(srcBD, tgtBD)]++;
+          perfectMutationSrcHistogram[getLocationBucket(srcPerfectBD, true)]++;
+          perfectMutationTgtHistogram[getLocationBucket(tgtPerfectBD, true)]++;
+          perfectMutationDistanceHistogram[getDistanceBucket(srcPerfectBD, tgtPerfectBD)]++;
+          mutationDistance.add(getLogDistance(srcPerfectBD, tgtPerfectBD));
+        }
+        if (verbose >= 5) Log.writeln("Pointer mutation logged");
+      }
+    }
+  }
+  
+  /**
+   * A pointer is live at GC time, perform appropriate bookkeeping.
+   * This should be called exactly once at each GC for each pointer in
+   * the graph of live objects.
+   * 
+   * We ignore pointers from objects with a null birthday, as these are
+   * either VM or compiler-generated objects.  The application being
+   * measured shouldn't be able to point to the VM !
+   * 
+   * @param src The object containing the mutated pointer
+   * @param tgt The object pointed to
+   */
+  public static final void livePointer(ObjectReference src, ObjectReference tgt)
+  throws NoInlinePragma {
+    long srcBD = getBirthdate(src);
+    if (srcBD != NULL_BIRTHDATE) {
+      totalPointers++;
+      if (VM.VERIFY_ASSERTIONS) VM.assertions._assert(!src.isNull());
+      if (!tgt.isNull()) {
+        if (verbose >= 4) Log.writeln("Logging live pointer");
+        long tgtBD = getBirthdate(tgt);
+        long srcPerfectBD = getPerfectBirthdate(srcBD);
+        long tgtPerfectBD = getPerfectBirthdate(tgtBD);
+        pointerSrcHistogram[getLocationBucket(srcBD, false)]++;
+        pointerTgtHistogram[getLocationBucket(tgtBD, false)]++;
+        pointerDistanceHistogram[getDistanceBucket(srcBD, tgtBD)]++;
+        perfectPointerSrcHistogram[getLocationBucket(srcPerfectBD, true)]++;
+        perfectPointerTgtHistogram[getLocationBucket(tgtPerfectBD, true)]++;
+        perfectPointerDistanceHistogram[getDistanceBucket(srcPerfectBD, tgtPerfectBD)]++;
+        pointerDistance.add(getLogDistance(srcPerfectBD, tgtPerfectBD));
+        
+        incRefCount(tgt);
+        if (verbose >= 4) Log.writeln("Logging live pointer - done");
+      }
+    }
+  }
+  
+  public static void resolvedClass(MMType type) {
+    if (measuring && VM.activePlan.mutator().currentScope == Plan.DEFAULT_SCOPE) {
+      newType(type);
+    }
+  }
+
+  /**
+   * @param type
+   */
+  private static int newType(MMType type) {
+    int id = maxType++;
+    type.setTypeId(id);
+    type.installBitmap();
+    types.set(id,ObjectReference.fromObject(type));
+    return id;
+  }
+
+  /**
+   * An object has been created, perform appropriate bookkeeping.
+   * This should be called each time an object is created.
+   *
+   * @param object The newly created object
+   * @param bytes The size of the new object in bytes
+   */
+  public static final void objectCreation(ObjectReference object, int bytes) 
+    throws NoInlinePragma {
+    
+    resetRefCount(object);
+    if (!measuring ||
+        VM.activePlan.mutator().currentScope != Plan.DEFAULT_SCOPE ||
+        Space.isInSpace(Plan.VM_SPACE, object)) {
+      VM.objectModel.setBirthdate(object, NULL_BIRTHDATE);
+    } else {
+      if (VM.VERIFY_ASSERTIONS) VM.assertions._assert(!object.isNull());
+      if (verbose >= 3) Log.writeln("Logging object creation");
+
+      /* Maintain the table of class descriptions */
+      MMType type = VM.objectModel.getObjectType(object);
+     if (type.getTypeId() == -1)
+        newType(type);
+      
+      bytes -= MEASUREMENT_HEADER_BYTES;
+      if (totalBytesAllocated > MAX_ALLOCATION - bytes)
+        VM.assertions.fail("Maximum allocation exceeded");
+      totalBytesAllocated += bytes;
+      totalObjectsAllocated++;
+      allocations.add(bytes);
+      currentAllocations.add(bytes);
+      if (type.isArray()) { 
+        arrayBytesAllocated += bytes;
+        totalArraysAllocated++;
+        arrayAllocations.add(bytes);
+        currentArrayAllocations.add(bytes);
+      }
+      if (type.isAcyclic()) { 
+        greenBytesAllocated += bytes;
+        totalGreenObjectsAllocated++;
+        greenAllocations.add(bytes);
+        currentGreenAllocations.add(bytes);
+      }
+      int cohort = getCohortFromBirthdate(totalBytesAllocated);
+      if (cohort > MAX_COHORTS)
+        VM.assertions.fail("Maximum cohorts exceeded - rerun with a larger cohort size");
+      totalLiveBytes += bytes;
+      totalLiveObjects++;
+      cohortLiveBytes[cohort] += bytes;
+      totalCohorts = cohort + 1;
+      VM.objectModel.setBirthdate(object, now());
+      if (VM.VERIFY_ASSERTIONS) {
+        long bday = VM.objectModel.getBirthdate(object);
+        if (bday != now()) {
+          Log.write("now() "); Log.write(now()); Log.write(" bday "); Log.writeln(bday);
+        }
+        VM.assertions._assert(bday == now());
+      }
+      if (verbose >= 3) { 
+        Log.write("Logging object creation - done "); Log.writeln(totalObjectsAllocated);
+      }
+      
+      // Per-class statistics
+      type.profileAlloc(bytes);
+      
+      // Pointer statistics
+      if (type.isReferenceArray()) {
+        arrayPointers.add(type.getReferences(object));
+        currentArrayPointers.add(type.getReferences(object));
+      } else {
+        scalarPointers.add(type.getReferences(object));
+        currentScalarPointers.add(type.getReferences(object));
+      }
+    }
+  }
+
+  /**
+   * An object is live at GC time, perform appropriate bookkeeping.
+   * This should be called exactly once at each GC for each object in
+   * the graph of live objects.
+   * 
+   * The hooks in the measurement collector ensure that this is called
+   * before any of the outgoing pointers are processed.
+   *
+   * @param object The live object
+   * @param bytes The size (in bytes) of the live object
+   */
+  public static final void liveObject(ObjectReference object, int bytes) 
+    throws NoInlinePragma {
+    long birthdate = getBirthdate(object);
+    if (birthdate != NULL_BIRTHDATE) {
+      bytes -= MEASUREMENT_HEADER_BYTES;
+      liveSizes.add(bytes);
+      currentLiveSizes.add(bytes);
+      currentLiveBytes += bytes;
+      currentLiveObjects++;
+      int cohort = getCohortFromBirthdate(birthdate);
+      cohortLiveBytes[cohort] += bytes;
+      cohortLiveObjects[cohort]++;
+      
+      // Pointer distribution at GC time
+      MMType type = VM.objectModel.getObjectType(object);
+      
+      if (type.isArray()) {
+        liveArraySizes.add(bytes);
+        currentLiveArraySizes.add(bytes);
+      }
+
+      if (type.isAcyclic()) {
+        liveGreenSizes.add(bytes);
+        currentLiveGreenSizes.add(bytes);
+      }
+
+      // Pointer statistics
+      if (type.isReferenceArray()) {
+        liveArrayPointers.add(type.getReferences(object));
+        currentLiveArrayPointers.add(type.getReferences(object));
+      } else {
+        liveScalarPointers.add(type.getReferences(object));
+        currentLiveScalarPointers.add(type.getReferences(object));
+      }
+
+      /*
+       * Track pointer-graph shape statistics, reference count and 
+       * outgoing pointer count, stored during the last GC
+       */
+      boolean touched = touched(object);
+      int refcount = resetRefCount(object);
+      if (!firstGc) {  // Ignore first GC
+        if (refcount == 0)
+          roots++;
+        if (touched) {
+          incomingPointerStats.add(refcount);
+          incomingPointers.add(refcount);
+          currentIncomingPointers.add(refcount);
+
+          int pointers = VM.objectModel.getPtrcount(object);
+          currentOutgoingPointers.add(pointers);
+          outgoingPointers.add(pointers);
+          outgoingPointerStats.add(pointers);
+        }
+      }
+
+      /* 
+       * Save the non-null pointers in the object header, to read out next GC
+       * along with the reference count
+       */
+      int pointers = 0;
+      for (int i=0; i < type.getReferences(object); i++)
+        if (!type.getSlot(object,i).loadObjectReference().isNull())
+          pointers++;
+      VM.objectModel.setPtrcount(object, pointers);
+    }
+  }
+
+  /**
+   * A collection is about to commence.  Clear counters.
+   */
+  public static final void gcStart() {
+    collections++;
+    for (int c = 0; c <= totalCohorts; c++) {
+      cohortLiveObjects[c] = 0;
+      cohortLiveBytes[c] = 0;
+    }
+    currentLiveObjects = 0;
+    currentLiveBytes = 0;
+  }
+
+  /**
+   * A collection has completed.  Perform appropriate bookkeeping and
+   * output statistics as necessary.
+   */
+  public static final void gcEnd() {
+    if (measuring) {
+      Xml.begin();
+      XmlMeasure.openTag("collection",true);
+      totalLiveBytes = currentLiveBytes;                  
+      totalLiveObjects = currentLiveObjects;              
+      maxLiveBytes = maxLiveBytes > currentLiveBytes ?
+              maxLiveBytes : currentLiveBytes;
+      maxLiveObjects = maxLiveObjects > currentLiveObjects ?
+              maxLiveObjects : currentLiveObjects;
+      sumLiveBytes += currentLiveBytes;
+      sumLiveObjects += currentLiveObjects;
+      printCollectionStats();
+      printHeapComposition();
+      printMutationHistograms();
+      printPointerHistograms();
+      recalculateCohortHeapPosition();
+      currentAllocations.printTable();
+      currentArrayAllocations.printTable();
+      currentGreenAllocations.printTable();
+      currentLiveSizes.printTable();
+      currentLiveArraySizes.printTable();
+      currentLiveGreenSizes.printTable();
+      currentScalarPointers.printTable();
+      currentArrayPointers.printTable();
+      currentLiveScalarPointers.printTable();
+      currentLiveArrayPointers.printTable();
+      currentIncomingPointers.printTable();
+      currentOutgoingPointers.printTable();
+      resetHistograms();
+      lastGCBirthdate = totalBytesAllocated;
+      lastGCPerfectBirthdate = totalLiveBytes;
+      firstGc = false;
+      Xml.closeTag();
+      Xml.end();
+    }
+  }
+  
+  /**
+   * Print overall run statistics
+   *
+   */
+  public static void harnessEnd() {
+    Xml.begin();
+    XmlMeasure.openTag("harness");
+    allocations.printTable();
+    arrayAllocations.printTable();
+    greenAllocations.printTable();
+    liveSizes.printTable();
+    liveArraySizes.printTable();
+    liveGreenSizes.printTable();
+    scalarPointers.printTable();
+    arrayPointers.printTable();
+    liveScalarPointers.printTable();
+    liveArrayPointers.printTable();
+    incomingPointers.printTable();
+    outgoingPointers.printTable();
+    printClassStatistics();
+    printTotals();
+    Xml.closeTag();
+    Xml.end();
+  }
+
+  public static final long now() {
+    return totalBytesAllocated;
+  }
+
+  private static final long getBirthdate(ObjectReference object) {
+    if (object.isNull()) 
+      return NULL_BIRTHDATE;
+    else
+       return VM.objectModel.getBirthdate(object);
+  }
+  
+  private static final long getPerfectBirthdate(long birthdate) {
+    if (birthdate == NULL_BIRTHDATE)
+      return birthdate;
+    if (birthdate >= lastGCBirthdate) {  // no GCs done since allocated
+      return lastGCPerfectBirthdate + (birthdate - lastGCBirthdate);
+    } else {
+      int cohort = getCohortFromBirthdate(birthdate);
+      int offset = getOffsetWithinCohort(birthdate);
+      long perfect = cohortHeapPosition[cohort];
+      double scale = (double) offset / (double) cohortSize;
+      perfect += (int) (cohortLiveBytes[cohort] * scale);
+      return perfect;
+    }
+  }
+
+  private static final int getLocationBucket(long birthdate, boolean perfect) {
+    if ((((perfect) ? totalLiveBytes : totalBytesAllocated) - birthdate) < 0) {
+      Log.write(lastGCBirthdate); Log.write(" "); Log.write(birthdate); 
+      Log.write((perfect) ? " p " : " n "); Log.writeln(totalLiveBytes);
+      VM.assertions._assert(false,"Use -X:gc:stressFactor to control GC frequency");
+    }
+    return logBaseTwo(((perfect) ? totalLiveBytes : totalBytesAllocated) - birthdate);
+  }
+  
+  private static final int getDistanceBucket(long srcBD, long tgtBD) {
+    return POINTER_DISTANCE_ZERO_BUCKET + getLogDistance(srcBD,tgtBD);
+  }
+  
+  private static final int getLogDistance(long srcBD, long tgtBD) {
+    if (srcBD == tgtBD)
+      return 0;
+    else if (tgtBD > srcBD) // young -> old
+      return logBaseTwo(tgtBD - srcBD);
+    else // old -> young
+      return -logBaseTwo(srcBD - tgtBD);
+  }
+
+  private static final int logBaseTwo(long value) {
+    if (VM.VERIFY_ASSERTIONS) 
+      VM.assertions._assert(value >= 0,"Attempt to calculate log2 of nonpositive number");
+    int l = 0;
+    while ((1<<l < value) && l < BITS_IN_INT)
+      l++;
+    return l;
+  }
+
+  private static final int getCohortFromBirthdate(long birthdate) {
+    if (VM.VERIFY_ASSERTIONS) 
+      VM.assertions._assert(birthdate != NULL_BIRTHDATE);
+    return (int)(birthdate >> logCohortSize);
+  }
+
+  private static final int getOffsetWithinCohort(long birthdate) {
+    return (int)(birthdate & (cohortSize - 1));  // We know that a cohort fits in an int.
+  }
+
+  private static final void recalculateCohortHeapPosition() {
+    int cumulativeLiveBytes = 0;
+    for (int c = 0; c < totalCohorts; c++) {
+      cohortHeapPosition[c] = cumulativeLiveBytes;
+      cumulativeLiveBytes += cohortLiveBytes[c];
+    }
+  }
+ 
+  private static final void resetHistograms() {
+    resetHistogram(mutationSrcHistogram);
+    resetHistogram(mutationTgtHistogram);
+    resetHistogram(mutationDistanceHistogram);
+    resetHistogram(perfectMutationSrcHistogram);
+    resetHistogram(perfectMutationTgtHistogram);
+    resetHistogram(perfectMutationDistanceHistogram);
+    resetHistogram(pointerSrcHistogram);
+    resetHistogram(pointerTgtHistogram);
+    resetHistogram(pointerDistanceHistogram);
+    resetHistogram(perfectPointerSrcHistogram);
+    resetHistogram(perfectPointerTgtHistogram);
+    resetHistogram(perfectPointerDistanceHistogram);
+    currentAllocations.reset();
+    currentArrayAllocations.reset();
+    currentGreenAllocations.reset();
+    currentLiveSizes.reset();
+    currentLiveArraySizes.reset();
+    currentLiveGreenSizes.reset();
+    currentScalarPointers.reset();
+    currentArrayPointers.reset();
+    currentLiveScalarPointers.reset();
+    currentLiveArrayPointers.reset();
+    currentIncomingPointers.reset();
+    currentOutgoingPointers.reset();
+  }
+
+  private static final void resetHistogram(long[] histo) {
+    for (int i = 0; i < histo.length; i++) histo[i] = 0;
+  }
+  
+  /************************************************************************************
+   * Print results
+   *
+   */
+  
+  /**
+   * Print stats that apply to 
+   */
+  private static final void printCollectionStats() {
+  }
+  
+  private static final void printHeapComposition() {
+    XmlMeasure.openTag("cohort-data",true,false);
+    Xml.attribute("liveObjects",totalLiveObjects); 
+    Xml.attribute("cohortSize",cohortSize); 
+    Xml.attribute("totalCohorts",totalCohorts); 
+    Xml.endTag(false);
+    
+    for (int c = 0; c < totalCohorts; c++) {
+      if (cohortLiveObjects[c] > 0) { // Reduce the output volume by not writing empty cohorts
+        Xml.openMinorTag("cohort");
+        Xml.attribute("id",c); 
+        Xml.attribute("o",cohortLiveObjects[c]); 
+        Xml.attribute("b",cohortLiveBytes[c]); 
+        Xml.closeMinorTag();
+      }
+    }
+    Xml.closeTag();
+  }
+
+  private static final void printMutationHistograms() {
+    XmlMeasure.openTag("mutation-data",true);
+    printLocationHistogram("mutation-src", mutationSrcHistogram,false);
+    printLocationHistogram("mutation-src", perfectMutationSrcHistogram,true);
+    printLocationHistogram("mutation-tgt", mutationTgtHistogram,false);
+    printLocationHistogram("mutation-tgt", perfectMutationTgtHistogram,true);
+    printDistanceHistogram("mutation-dist", mutationDistanceHistogram,false);
+    printDistanceHistogram("mutation-dist", perfectMutationDistanceHistogram,true);
+    Xml.closeTag();
+  }
+
+  private static final void printPointerHistograms() {
+    XmlMeasure.openTag("pointer-data",true);
+    printLocationHistogram("pointer-src", pointerSrcHistogram,false);
+    printLocationHistogram("pointer-src", perfectPointerSrcHistogram,true);
+    printLocationHistogram("pointer-tgt", pointerTgtHistogram,false);
+    printLocationHistogram("pointer-tgt", perfectPointerTgtHistogram,true);
+    printDistanceHistogram("pointer-dist", pointerDistanceHistogram,false);
+    printDistanceHistogram("pointer-dist", perfectPointerDistanceHistogram,true);
+    Xml.closeTag();
+  }
+  
+  private static final void printLocationHistogram(String tag, long[] hist,boolean perfect) {
+    XmlMeasure.openTag(tag,true,false);
+    if (perfect)
+      Xml.attribute("perfect","true");
+    Xml.endTag(false);
+    for (int b = 0; b < hist.length; b++) {
+      Xml.openMinorTag("bucket");
+      Xml.attribute("key",b); 
+      Xml.attribute("value",hist[b]);
+      Xml.closeMinorTag();
+    }
+    Xml.closeTag();
+  }
+  
+  private static final void printDistanceHistogram(String tag, long[] hist, boolean perfect) {
+    XmlMeasure.openTag(tag,true,false);
+    if (perfect)
+      Xml.attribute("perfect","true");
+    Xml.endTag(false);
+    for (int b = 0; b < hist.length; b++) {
+      Xml.openMinorTag("bucket");
+      Xml.attribute("key",b-POINTER_DISTANCE_ZERO_BUCKET); 
+      Xml.attribute("value",hist[b]);
+      Xml.closeMinorTag();
+    }
+    Xml.closeTag();
+  }
+  
+  private static final void printClassStatistics() {
+    Xml.singleValue("classes-loaded",maxType);
+    XmlMeasure.openTag("per-class-data");
+    for (int i=0; i < maxType; i++) {
+      MMType type = (MMType)types.get(i).toObject();
+      if (type == null) 
+	      Xml.comment("null type encountered");
+      else {
+      Xml.openMinorTag("class");
+      Xml.attribute("name",type.getName()); 
+      Log.writeln();
+      Xml.attribute("objects",type.getAllocCount()); 
+      Xml.attribute("bytes",type.getAllocBytes());
+      Log.writeln();
+      if (!type.isReferenceArray()) {
+        if (!type.isArray())
+          Xml.attribute("pointers",type.getReferences(null));
+        Xml.attribute("bitmap",type.getBitmap());
+     } else {
+        Xml.attribute("refarray","true");
+      }
+      Xml.closeMinorTag();
+      }
+    }
+    Xml.closeTag();
+  }
+  
+  static void timestamps() {
+    Xml.attribute("alloc-bytes",totalBytesAllocated);
+    Xml.attribute("mutations",totalMutations);
+    Xml.attribute("alloc-objects",totalObjectsAllocated);
+    Xml.attribute("collections",collections);
+  }
+  
+  /**
+   * Print once-per-run totals
+   *
+   */
+  private static void printTotals() {
+    Xml.singleValue("total-objects-allocated",totalObjectsAllocated);
+    Xml.singleValue("total-bytes-allocated",totalBytesAllocated);
+    Xml.singleValue("total-mutations",totalMutations);
+    Xml.singleValue("max-resident-bytes",maxLiveBytes);
+    Xml.singleValue("max-resident-objects",maxLiveObjects);
+    Xml.singleValue("total-resident-bytes",sumLiveBytes);
+    Xml.singleValue("total-resident-objects",sumLiveObjects);
+    Xml.singleValue("total-arrays-allocated",totalArraysAllocated);
+    Xml.singleValue("array-bytes-allocated",arrayBytesAllocated);
+    Xml.singleValue("total-green-objects-allocated",totalGreenObjectsAllocated);
+    Xml.singleValue("green-bytes-allocated",greenBytesAllocated);
+    Xml.singleValue("cohort-size",Options.cohortSize.getBytes().toInt());
+    Xml.singleValue("gc-interval",Options.stressFactor.getBytes().toInt());
+    Xml.singleValue("incoming-pointers",incomingPointerStats.getSum());   
+    Xml.singleValue("incoming-objects",incomingPointerStats.getCount());
+    Xml.singleValue("mean-incoming-pointers",incomingPointerStats.getMean());
+    Xml.singleValue("var-incoming-pointers",incomingPointerStats.getVariance());
+    Xml.singleValue("outgoing-pointers",outgoingPointerStats.getSum());
+    Xml.singleValue("outgoing-objects",outgoingPointerStats.getCount());
+    Xml.singleValue("mean-outgoing-pointers",outgoingPointerStats.getMean());
+    Xml.singleValue("var-outgoing-pointers",outgoingPointerStats.getVariance());
+    Xml.singleValue("roots",roots);
+    Xml.singleValue("mean-pointer-dist",pointerDistance.getMean());
+    Xml.singleValue("mean-mutation-dist",mutationDistance.getMean());
+    Xml.singleValue("var-pointer-dist",pointerDistance.getVariance());
+    Xml.singleValue("var-mutation-dist",mutationDistance.getVariance());
+  }
+  
+  /*****************************************************************************
+   * Managing reference counts
+   */
+  
+  private static final Word TOUCHED_BIT = Word.one().lsh(31);
+  private static final Word RC_MASK = TOUCHED_BIT.not();
+  
+  /**
+   * 
+   */
+  private static void setRefCount(ObjectReference obj, int count) {
+    VM.objectModel.setRefcount(obj, TOUCHED_BIT.or(Word.fromIntZeroExtend(count)));
+  }
+  
+  private static int getRefCount(ObjectReference obj) {
+    return VM.objectModel.getRefcount(obj).and(RC_MASK).toInt();
+  }
+  
+  private static boolean touched(ObjectReference obj) {
+    return VM.objectModel.getRefcount(obj).and(TOUCHED_BIT).EQ(TOUCHED_BIT);
+  }
+  
+  private static void incRefCount(ObjectReference obj) {
+    setRefCount(obj, getRefCount(obj)+1);
+  }
+  
+  private static void decRefCount(ObjectReference obj) {
+    setRefCount(obj, getRefCount(obj)-1);
+  }
+  
+  private static int resetRefCount(ObjectReference obj) {
+    int count = getRefCount(obj);
+    VM.objectModel.setRefcount(obj, Word.zero());
+    return count;
+  }
+
+
+}
diff -r -N -w -u -I '[$]Id:' --exclude='*.class' --exclude='.*' --exclude='*.orig' --exclude='*.rej' --exclude=CVS --exclude='#*' --exclude='*~' ./MMTk/src/org/mmtk/utility/statistics/Xml.java ./MMTk/src/org/mmtk/utility/statistics/Xml.java
--- ./MMTk/src/org/mmtk/utility/statistics/Xml.java	2006-11-27 10:21:46.000000000 +1100
+++ ./MMTk/src/org/mmtk/utility/statistics/Xml.java	2006-11-27 11:13:16.000000000 +1100
@@ -5,7 +5,6 @@
 package org.mmtk.utility.statistics;
 
 import org.mmtk.utility.Log;
-import org.mmtk.vm.Assert;
 import org.mmtk.vm.VM;
 import org.vmmagic.pragma.Uninterruptible;
 import org.vmmagic.unboxed.ObjectReference;
diff -r -N -w -u -I '[$]Id:' --exclude='*.class' --exclude='.*' --exclude='*.orig' --exclude='*.rej' --exclude=CVS --exclude='#*' --exclude='*~' ./MMTk/src/org/mmtk/utility/statistics/XmlMeasure.java ./MMTk/src/org/mmtk/utility/statistics/XmlMeasure.java
--- ./MMTk/src/org/mmtk/utility/statistics/XmlMeasure.java	1970-01-01 10:00:00.000000000 +1000
+++ ./MMTk/src/org/mmtk/utility/statistics/XmlMeasure.java	2006-11-27 11:57:47.000000000 +1100
@@ -0,0 +1,30 @@
+/**
+ * Copyright (c) 2006 Australian National University
+ */
+package org.mmtk.utility.statistics;
+
+import org.vmmagic.pragma.*;
+
+/**
+ * Extensions to Xml specifically for output from the Measurement collector.
+ * 
+ * @author Robin Garner
+ * @date $Date:$
+ * @id $Id:$
+ *
+ */
+public class XmlMeasure extends Xml implements Uninterruptible {
+  static void openTag(String name, boolean timestamp, boolean endTag) {
+    pushTag(name);
+    openMinorTag(name);
+    if (timestamp)
+      Measurement.timestamps(); 
+    if (endTag)
+      endTag(false);
+  }
+
+  static void openTag(String name, boolean timestamp) {
+    openTag(name,timestamp,true);
+  }
+
+}
diff -r -N -w -u -I '[$]Id:' --exclude='*.class' --exclude='.*' --exclude='*.orig' --exclude='*.rej' --exclude=CVS --exclude='#*' --exclude='*~' ./MMTk/src/org/mmtk/vm/ObjectModel.java ./MMTk/src/org/mmtk/vm/ObjectModel.java
--- ./MMTk/src/org/mmtk/vm/ObjectModel.java	2006-11-27 10:20:07.000000000 +1100
+++ ./MMTk/src/org/mmtk/vm/ObjectModel.java	2006-11-23 17:28:41.000000000 +1100
@@ -236,4 +236,28 @@
     return o.getArrayBaseOffset();
   }
 
+  /****************************************
+   * Methods for the measurement collector
+   ****************************************/
+  
+  /**
+   * set the birthdate of an object
+   */
+  public abstract void setBirthdate(ObjectReference object, long birthday);
+  
+  /**
+   * get the birthdate of an object
+   */
+  public abstract long getBirthdate(ObjectReference object);
+  
+  /**
+   * get/set the refcount of an object
+   */
+  public abstract void setRefcount(ObjectReference object, Word count);
+  public abstract Word getRefcount(ObjectReference object);
+  
+  public abstract void setPtrcount(ObjectReference object, int count);
+  public abstract int getPtrcount(ObjectReference object);
+  
+
 }
diff -r -N -w -u -I '[$]Id:' --exclude='*.class' --exclude='.*' --exclude='*.orig' --exclude='*.rej' --exclude=CVS --exclude='#*' --exclude='*~' ./rvm/src/vm/memoryManagers/JMTk/vmInterface/MM_Interface.java ./rvm/src/vm/memoryManagers/JMTk/vmInterface/MM_Interface.java
--- ./rvm/src/vm/memoryManagers/JMTk/vmInterface/MM_Interface.java	2006-11-27 10:20:06.000000000 +1100
+++ ./rvm/src/vm/memoryManagers/JMTk/vmInterface/MM_Interface.java	2006-11-27 12:27:57.000000000 +1100
@@ -28,6 +28,7 @@
 import org.mmtk.utility.Memory;
 import org.mmtk.utility.scan.MMType;
 import org.mmtk.utility.statistics.Stats;
+import org.mmtk.utility.statistics.Measurement;
 import org.mmtk.utility.options.*;
 import com.ibm.JikesRVM.mm.mmtk.Assert;
 import com.ibm.JikesRVM.mm.mmtk.Lock;
@@ -1026,17 +1027,25 @@
     if (vmType.isArrayType()) {
       type = new MMType(false,
                         vmType.asArray().getElementType().isReferenceType(),
+                        true,
                         vmType.isAcyclicReference(),
                         pickAllocatorForType(vmType),
-                        zeroLengthIntArray);
+                        zeroLengthIntArray,
+                        vmType.getDescriptor().toByteArray());
     } else {
       type = new MMType(false,
                         false,
+                        false,
                         vmType.isAcyclicReference(),
                         pickAllocatorForType(vmType),
-                        vmType.asClass().getReferenceOffsets());
+                        vmType.asClass().getReferenceOffsets(),
+                        vmType.getDescriptor().toByteArray());
     }
     vmType.setMMType(type);
+    if (VM.runningVM) {
+      type.installBitmap();
+      Measurement.resolvedClass(type);
+    }
   }
 
   /**
@@ -1045,8 +1054,8 @@
    * benchmark, such as a full heap collection, turning on
    * instrumentation, etc.
    */
-  public static void harnessBegin() throws InterruptiblePragma {
-    Plan.harnessBegin();
+  public static void harnessBegin() throws UninterruptibleNoWarnPragma {
+    SelectedPlan.get().harnessBegin();
   }
 
   /**
@@ -1055,8 +1064,8 @@
    * benchmark, such as a full heap collection, turning off
    * instrumentation, etc.
    */
-  public static void harnessEnd() {
-    Plan.harnessEnd();
+  public static void harnessEnd() throws UninterruptibleNoWarnPragma {
+    SelectedPlan.get().harnessEnd();
   }
 
   /**
diff -r -N -w -u -I '[$]Id:' --exclude='*.class' --exclude='.*' --exclude='*.orig' --exclude='*.rej' --exclude=CVS --exclude='#*' --exclude='*~' ./config/build/BaseAdaptiveMeasurement ./config/build/BaseAdaptiveMeasurement
--- ./config/build/BaseAdaptiveMeasurement	1970-01-01 10:00:00.000000000 +1000
+++ ./config/build/BaseAdaptiveMeasurement	2006-11-23 17:24:52.000000000 +1100
@@ -0,0 +1,2 @@
+. $1/gc/Measurement
+. $1/compilers/BaseAdaptive
diff -r -N -w -u -I '[$]Id:' --exclude='*.class' --exclude='.*' --exclude='*.orig' --exclude='*.rej' --exclude=CVS --exclude='#*' --exclude='*~' ./config/build/BaseBaseMeasurement ./config/build/BaseBaseMeasurement
--- ./config/build/BaseBaseMeasurement	1970-01-01 10:00:00.000000000 +1000
+++ ./config/build/BaseBaseMeasurement	2006-11-23 17:24:52.000000000 +1100
@@ -0,0 +1,2 @@
+. $1/gc/Measurement
+. $1/compilers/BaseBase
diff -r -N -w -u -I '[$]Id:' --exclude='*.class' --exclude='.*' --exclude='*.orig' --exclude='*.rej' --exclude=CVS --exclude='#*' --exclude='*~' ./config/build/FastAdaptiveMeasurement ./config/build/FastAdaptiveMeasurement
--- ./config/build/FastAdaptiveMeasurement	1970-01-01 10:00:00.000000000 +1000
+++ ./config/build/FastAdaptiveMeasurement	2006-11-23 17:24:52.000000000 +1100
@@ -0,0 +1,2 @@
+. $1/gc/Measurement
+. $1/compilers/FastAdaptive
diff -r -N -w -u -I '[$]Id:' --exclude='*.class' --exclude='.*' --exclude='*.orig' --exclude='*.rej' --exclude=CVS --exclude='#*' --exclude='*~' ./config/build/FullAdaptiveMeasurement ./config/build/FullAdaptiveMeasurement
--- ./config/build/FullAdaptiveMeasurement	1970-01-01 10:00:00.000000000 +1000
+++ ./config/build/FullAdaptiveMeasurement	2006-11-23 17:24:52.000000000 +1100
@@ -0,0 +1,2 @@
+. $1/gc/Measurement
+. $1/compilers/FullAdaptive
diff -r -N -w -u -I '[$]Id:' --exclude='*.class' --exclude='.*' --exclude='*.orig' --exclude='*.rej' --exclude=CVS --exclude='#*' --exclude='*~' ./config/build/gc/Measurement ./config/build/gc/Measurement
--- ./config/build/gc/Measurement	1970-01-01 10:00:00.000000000 +1000
+++ ./config/build/gc/Measurement	2006-11-23 17:24:52.000000000 +1100
@@ -0,0 +1,3 @@
+   export RVM_WITH_MMTK_INLINE_PLAN=1
+   export RVM_WITH_MMTK_PLAN="org.mmtk.plan.measurement.Measure"
+
